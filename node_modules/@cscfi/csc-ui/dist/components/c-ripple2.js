import { proxyCustomElement, HTMLElement, h, Host } from '@stencil/core/internal/client';

const cRippleCss = "html{box-sizing:border-box}body{margin:0}*,*:before,*:after{box-sizing:inherit;-webkit-tap-highlight-color:transparent}:host{font-family:var(--c-font-family)}::-ms-reveal{display:none}:host{pointer-events:none;user-select:none;display:block;overflow:hidden;position:absolute;top:0;left:0;border-radius:inherit;z-index:1}.c-ripple{position:absolute;pointer-events:none;border-radius:50%;transform:scale(0);background:currentColor;opacity:0}.c-ripple.animate{animation:ripple 0.5s backwards linear;opacity:0.3}@keyframes ripple{100%{opacity:0;transform:scale(5)}}";

const CRipple = proxyCustomElement(class CRipple extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
  }
  async createRipple(event, parent, center = false) {
    this._rippleElement.classList.remove('animate');
    const width = parent.offsetWidth;
    const height = parent.offsetHeight;
    const rect = event.target.getBoundingClientRect();
    const maxDimension = this._calculateHeight(Math.max(parent.offsetWidth, parent.offsetHeight));
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    const top = y - maxDimension / 2 + 'px';
    const left = x - maxDimension / 2 + 'px';
    const centerPosition = {
      top: maxDimension === height
        ? '0px'
        : ((maxDimension - height) / 2) * -1 + 'px',
      left: maxDimension === width
        ? '0px'
        : ((maxDimension - width) / 2) * -1 + 'px',
    };
    this.el.style.width = width + 'px';
    this.el.style.height = height + 'px';
    this._rippleElement.style.width = maxDimension + 'px';
    this._rippleElement.style.height = maxDimension + 'px';
    this._rippleElement.style.top = center ? centerPosition.top : top;
    this._rippleElement.style.left = center ? centerPosition.left : left;
    this._rippleElement.classList.add('animate');
    setTimeout(() => {
      this._rippleElement.classList.remove('animate');
    }, 500);
  }
  _calculateHeight(height) {
    const radius = (height / 2) * Math.sqrt(2);
    return radius * 2;
  }
  render() {
    return (h(Host, { "aria-hidden": "true" }, h("div", { ref: (el) => (this._rippleElement = el), class: "c-ripple" })));
  }
  get el() { return this; }
  static get style() { return cRippleCss; }
}, [1, "c-ripple", {
    "createRipple": [64]
  }]);
function defineCustomElement() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["c-ripple"];
  components.forEach(tagName => { switch (tagName) {
    case "c-ripple":
      if (!customElements.get(tagName)) {
        customElements.define(tagName, CRipple);
      }
      break;
  } });
}

export { CRipple as C, defineCustomElement as d };

//# sourceMappingURL=c-ripple2.js.map