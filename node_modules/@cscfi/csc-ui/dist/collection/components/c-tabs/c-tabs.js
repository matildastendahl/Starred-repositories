import { mdiArrowLeft, mdiArrowRight } from "@mdi/js";
import { h, Host, } from "@stencil/core";
var ScrollDirection;
(function (ScrollDirection) {
  ScrollDirection[ScrollDirection["Left"] = 2] = "Left";
  ScrollDirection[ScrollDirection["Right"] = 4] = "Right";
})(ScrollDirection || (ScrollDirection = {}));
export class CTabs {
  constructor() {
    this._initialized = false;
    this._debounce = null;
    this._moveDebounce = null;
    this._isDirty = false;
    this._focusedTabValue = this.value;
    this._intersectionObserver = new IntersectionObserver(([entry]) => {
      if (entry.isIntersecting) {
        setTimeout(() => {
          this._handleOverflow();
        }, 1000);
      }
    }, { threshold: 1 });
    this._previousWidth = 0;
    this._maxScrollOffset = 0;
    this._startX = 0;
    this._touchOffset = 0;
    this.value = undefined;
    this.borderless = false;
    this.disableAnimation = false;
    this.justify = 'stretch';
    this.mobileBreakpoint = 640;
    this.vertical = false;
    this.isOverflowing = false;
    this.isMobile = false;
    this.scrollOffset = 0;
  }
  onJustificationChange() {
    this._handleActiveTab();
  }
  onExternalValueChange() {
    this._handleActiveTab();
    this.changeValue.emit(this.value);
    this._updateItemsValue();
  }
  tabFocusHandler(event) {
    event.stopPropagation();
    this._focusedTabValue = event.detail;
  }
  tabChangeHandler(event) {
    event.stopPropagation();
    this.value = event.detail.value;
  }
  handleKeyDown(event) {
    if (!this.tabs.includes(event.target) || event.target.disabled)
      return;
    if (event.key === 'Enter' || event.code === 'Space') {
      this.value = event.target.value;
    }
  }
  handleKeyUp(event) {
    this._isDirty = true;
    if (!this.tabs.includes(event.target))
      return;
    const isArrowLeft = event.key === 'ArrowLeft';
    const isArrowRight = event.key === 'ArrowRight';
    if (!isArrowRight && !isArrowLeft)
      return;
    const tabIndex = this._getTabIndex(this._focusedTabValue);
    const firstAvailableValue = this.availableValues.at(0);
    const lastAvailableValue = this.availableValues.at(-1);
    const isBeginning = this._focusedTabValue === firstAvailableValue;
    const isEnd = this._focusedTabValue === lastAvailableValue;
    const nextValue = isEnd
      ? firstAvailableValue
      : this.availableValues[tabIndex + 1];
    const previousValue = isBeginning
      ? lastAvailableValue
      : this.availableValues[tabIndex - 1];
    if (isArrowLeft) {
      if (isBeginning)
        return;
      this._focusTab(previousValue);
    }
    if (isArrowRight) {
      if (isEnd)
        return;
      this._focusTab(nextValue);
    }
  }
  get _prefersReducedMotion() {
    return (window.matchMedia('(prefers-reduced-motion: reduce)').matches ||
      this.disableAnimation);
  }
  get _tabItems() {
    return this.el.querySelector(':scope > c-tab-items');
  }
  get _tabButtons() {
    return this.el.querySelector(':scope > c-tab-buttons');
  }
  _updateItemsValue() {
    this.tabItems.value = this.value;
    if (this._tabButtons) {
      this._tabButtons.value = this.value;
    }
  }
  componentWillLoad() {
    CTabs._uniqueId += 1;
    this._tabItems.disableAnimation = this._prefersReducedMotion;
    if (this._tabButtons) {
      this.el.classList.add('c-tabs--buttons');
      this._tabButtons.setAttribute('tabs', 'true');
    }
    this._updateItemsValue();
  }
  componentDidLoad() {
    this._resizeObserver = new ResizeObserver((entries) => {
      this._handleResize(entries[0].contentRect.width);
    });
    this._resizeObserver.observe(this.el);
    this._intersectionObserver.observe(this.el);
    this.el.style.setProperty('--_c-tabs-count', this.setsize.toString());
    requestAnimationFrame(() => {
      this._handleOverflow();
    });
  }
  disconnectedCallback() {
    this._intersectionObserver.disconnect();
  }
  get tabs() {
    if (!!this._tabButtons) {
      return Array.from(this._tabButtons.querySelectorAll(':scope > c-button'));
    }
    return Array.from(this.el.querySelectorAll(':scope > c-tab'));
  }
  get tabItems() {
    return this.el.querySelector('c-tab-items');
  }
  get setsize() {
    return this.tabs.length;
  }
  get availableValues() {
    return this.tabs.map((tab) => tab.value);
  }
  _getTabIndex(value) {
    return this.availableValues.findIndex((tab) => tab === value);
  }
  _setIndicatorTop(value) {
    const container = this.el.shadowRoot.querySelector('.c-tabs__tabs');
    container.style.setProperty('--_c-tabs-indicator-top', `${value}px`);
  }
  _setIndicatorLeft(value) {
    const container = this.el.shadowRoot.querySelector('.c-tabs__tabs');
    container.style.setProperty('--_c-tabs-indicator-left', `${value}px`);
  }
  _setIndicatorWidth(value) {
    const container = this.el.shadowRoot.querySelector('.c-tabs__tabs');
    container.style.setProperty('--_c-tabs-indicator-width', value.toString());
  }
  _handleActiveTab() {
    requestAnimationFrame(() => {
      var _a;
      let position = 0;
      const oldTab = (_a = this.el.querySelector('[aria-selected="true"]')) !== null && _a !== void 0 ? _a : this.tabs[0];
      this.tabs.forEach((tab, index) => {
        if (!tab.disabled) {
          position += 1;
        }
        const isActive = tab.value === this.value;
        const tabId = `c-tab-${CTabs._uniqueId}-${index + 1}`;
        const tabItemId = `c-tab-item-${CTabs._uniqueId}-${index + 1}`;
        tab.setAttribute('id', tabId);
        tab.setAttribute('aria-controls', tabItemId);
        if (!this._tabButtons) {
          tab.active = isActive;
        }
        else if (isActive) {
          this._tabButtons.value = tab.value;
        }
        const item = Array.from(this.tabItems.querySelectorAll(':scope > c-tab-item')).find((child) => child.value === tab.value);
        item.setAttribute('disabled', (!!tab.disabled).toString());
        item.setAttribute('id', tabItemId);
        item.setAttribute('aria-labelledby', tabId);
        item.active = isActive;
        item.setAttribute('active', isActive.toString());
        if (!tab.disabled) {
          tab.setAttribute('aria-posinset', position.toString());
          tab.setAttribute('setsize', this.availableValues.length.toString());
        }
        if (isActive && !this._tabButtons) {
          this._moveIndicator(oldTab, tab);
          requestAnimationFrame(() => {
            if (!this.isOverflowing)
              return;
            const selectedTab = this.el.querySelector('c-tab[aria-selected="true"]');
            this._moveToTab(selectedTab);
            this._tabsTabsElement.style.setProperty('--_c-tabs-transition-speed', '200ms');
          });
        }
        if (isActive && this._isDirty) {
          tab.focus();
        }
      });
    });
  }
  _getDimensions(item) {
    const { x, width } = item.getBoundingClientRect();
    const { x: containerX, width: containerWidth } = this._tabsTabsElement.getBoundingClientRect();
    const { x: scrollerX, width: scrollerWidth } = this._tabsScrollElement.getBoundingClientRect();
    return {
      x,
      width,
      containerWidth,
      containerX,
      scrollerX,
      scrollerWidth,
    };
  }
  _focusTab(value) {
    if (this._tabButtons) {
      return;
    }
    requestAnimationFrame(() => {
      const item = this.tabs.find((tab) => tab.value === value);
      const { x, width, containerX, containerWidth } = this._getDimensions(item);
      const isInView = x >= containerX && x + width <= containerX + containerWidth;
      if (isInView) {
        item === null || item === void 0 ? void 0 : item.focus();
        return;
      }
      this._moveToTab(item);
    });
  }
  _handleResize(width) {
    if (this._moveDebounce !== null)
      return;
    if (this._debounce !== null) {
      clearTimeout(this._debounce);
      this._debounce = null;
    }
    this._debounce = setTimeout(() => {
      const content = this.el.shadowRoot.querySelector('.c-tabs__scroll');
      const container = this.el.shadowRoot.querySelector('.c-tabs__tabs');
      requestAnimationFrame(() => {
        if (width === this._previousWidth)
          return;
        this._handleOverflow();
        this.isMobile = width < this.mobileBreakpoint;
        this._maxScrollOffset =
          -1 * (content.scrollWidth - container.clientWidth);
        this._handleActiveTab();
        this._previousWidth = width;
      });
    }, 200);
  }
  _moveIndicator(oldTab, newTab) {
    if (this._moveDebounce !== null)
      return;
    this._moveDebounce = setTimeout(() => {
      requestAnimationFrame(() => {
        const content = this.el.shadowRoot.querySelector('.c-tabs__scroll');
        const container = this.el.shadowRoot.querySelector('.c-tabs__tabs');
        if (this._initialized && !this._prefersReducedMotion) {
          container.style.setProperty('--_c-tabs-transition-speed', '200ms');
        }
        const buttonOffset = this.isOverflowing ? 32 : 0;
        const newTabWidth = newTab.offsetWidth / content.offsetWidth;
        const newTabHeight = this.vertical
          ? newTab.offsetHeight / content.offsetHeight
          : newTab.offsetHeight / content.offsetHeight;
        const newTabPosition = oldTab.compareDocumentPosition(newTab);
        let transitionWidth = 0;
        if (newTabPosition === ScrollDirection.Right) {
          transitionWidth = this.vertical
            ? newTab.offsetTop + newTab.offsetHeight - oldTab.offsetTop
            : newTab.offsetLeft + newTab.offsetWidth - oldTab.offsetLeft;
        }
        else {
          transitionWidth = this.vertical
            ? oldTab.offsetTop + oldTab.offsetHeight - newTab.offsetTop
            : oldTab.offsetLeft + oldTab.offsetWidth - newTab.offsetLeft;
          this._setIndicatorLeft(newTab.offsetLeft - buttonOffset);
          this._setIndicatorTop(newTab.offsetTop - buttonOffset);
        }
        this._setIndicatorWidth(this.vertical
          ? transitionWidth / content.offsetHeight
          : transitionWidth / content.offsetWidth);
        const onTransitionEnd = (event) => {
          if (event.propertyName !== 'scale')
            return;
          this._setIndicatorLeft(newTab.offsetLeft - buttonOffset);
          this._setIndicatorTop(newTab.offsetTop - buttonOffset);
          this._setIndicatorWidth(this.vertical ? newTabHeight : newTabWidth);
          content.removeEventListener('transitionend', onTransitionEnd);
          if (!this._initialized) {
            this.el.classList.add('c-tabs--initialized');
          }
          this._initialized = true;
        };
        content.addEventListener('transitionend', onTransitionEnd);
      });
      clearTimeout(this._moveDebounce);
      this._moveDebounce = null;
    }, 200);
  }
  onScrollOffsetChange(offset) {
    this._tabsTabsElement.style.setProperty('--_c-tabs-scroll-position-x', `${offset}px`);
  }
  _handleOverflow() {
    if (this._tabButtons) {
      this.isOverflowing = false;
      return;
    }
    const content = this.el.shadowRoot.querySelector('.c-tabs__scroll');
    const container = this.el.shadowRoot.querySelector('.c-tabs__tabs');
    const contentSize = content.scrollWidth;
    const containerSize = container.clientWidth;
    this.isOverflowing = containerSize + 1 < contentSize;
  }
  _onTouchEnd() {
    this._tabsTabsElement.style.setProperty('--_c-tabs-transition-speed', '200ms');
  }
  _onTouchMove(event) {
    if (this.vertical)
      return;
    event.preventDefault();
    this._tabsTabsElement.style.setProperty('--_c-tabs-transition-speed', '0ms');
    const offset = -1 * (this._touchOffset + this._startX - event.touches[0].clientX);
    const isInRange = offset <= 0 && offset >= this._maxScrollOffset;
    if (isInRange) {
      this.scrollOffset = offset;
    }
    else if (offset > 0 || !this.isOverflowing) {
      this.scrollOffset = 0;
    }
    else if (offset < this._maxScrollOffset) {
      this.scrollOffset = this._maxScrollOffset;
    }
  }
  _onTouchStart(event) {
    this._handleOverflow();
    if (!this.isOverflowing)
      return;
    this._touchOffset = this.scrollOffset * -1;
    this._startX = event.touches[0].clientX;
  }
  _onBackClick() {
    const min = 0;
    const step = this._tabsTabsElement.clientWidth / 2;
    this.scrollOffset = Math.min(this.scrollOffset + step, min);
  }
  _onForwardClick() {
    const max = (this._tabsScrollElement.scrollWidth -
      this._tabsTabsElement.clientWidth) *
      -1;
    const step = this._tabsTabsElement.clientWidth / 2;
    this.scrollOffset = Math.max(-1 * step + this.scrollOffset, max);
  }
  _moveToTab(tab) {
    const onTransitionEnd = () => {
      tab === null || tab === void 0 ? void 0 : tab.focus();
      this._tabsScrollElement.removeEventListener('transitionend', onTransitionEnd);
    };
    requestAnimationFrame(() => {
      const tabIndex = this._getTabIndex(tab.dataset.value);
      const isFirstTab = tabIndex === 0;
      const isLastTab = tabIndex === this.availableValues.length - 1;
      if (isFirstTab) {
        this.scrollOffset = 0;
        return;
      }
      if (isLastTab) {
        this.scrollOffset = this._maxScrollOffset - 8;
        return;
      }
      const { x, width, containerWidth, containerX } = this._getDimensions(tab);
      const tabEnd = x + width;
      const containerEnd = containerX + containerWidth;
      const isOverflowingStart = x < containerX;
      const isOverflowingEnd = tabEnd > containerEnd;
      if (isOverflowingStart) {
        const tabInside = tabEnd - containerX;
        const tabOutside = tabInside - width;
        this.scrollOffset = this.scrollOffset - tabOutside + 4;
      }
      if (isOverflowingEnd) {
        this.scrollOffset -= tabEnd - containerEnd + 4;
      }
    });
    const content = this.el.shadowRoot.querySelector('.c-tabs__scroll');
    content.addEventListener('transitionend', onTransitionEnd);
  }
  render() {
    const classes = {
      'c-tabs': true,
      'c-tabs--borderless': this.borderless,
      'c-tabs--vertical': this.vertical,
      'c-tabs--overflow': this.isOverflowing,
      'c-tabs--mobile': this.isMobile,
      [`c-tabs--justify-${this.justify}`]: true,
    };
    return (h(Host, { role: "tablist", class: classes }, h("div", { class: "c-tabs__container" }, this.isOverflowing && !this.vertical && (h("c-icon-button", { size: "x-small", ghost: true, onClick: this._onBackClick.bind(this) }, h("c-icon", { path: mdiArrowLeft }))), h("div", { ref: (el) => (this._tabsTabsElement = el), class: "c-tabs__tabs", onTouchStart: this._onTouchStart.bind(this), onTouchMove: this._onTouchMove.bind(this), onTouchEnd: this._onTouchEnd.bind(this) }, h("div", { ref: (el) => (this._tabsScrollElement = el), class: "c-tabs__scroll" }, h("slot", null))), this.isOverflowing && !this.vertical && (h("c-icon-button", { size: "x-small", ghost: true, onClick: this._onForwardClick.bind(this) }, h("c-icon", { path: mdiArrowRight })))), h("div", { class: "c-tabs__content" }, h("slot", { name: "items" }))));
  }
  static get is() { return "c-tabs"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["c-tabs.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["c-tabs.css"]
    };
  }
  static get properties() {
    return {
      "value": {
        "type": "any",
        "mutable": true,
        "complexType": {
          "original": "number | string",
          "resolved": "number | string",
          "references": {}
        },
        "required": true,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "Currently active tab"
        },
        "attribute": "value",
        "reflect": false
      },
      "borderless": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "Disable the bottom border"
        },
        "attribute": "borderless",
        "reflect": false,
        "defaultValue": "false"
      },
      "disableAnimation": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "Disable animation"
        },
        "attribute": "disable-animation",
        "reflect": false,
        "defaultValue": "false"
      },
      "justify": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "CTabsJustify",
          "resolved": "\"center\" | \"end\" | \"start\" | \"stretch\"",
          "references": {
            "CTabsJustify": {
              "location": "import",
              "path": "../../types",
              "id": "src/types/index.ts::CTabsJustify"
            }
          }
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "Justification of the children"
        },
        "attribute": "justify",
        "reflect": false,
        "defaultValue": "'stretch'"
      },
      "mobileBreakpoint": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "Mobile breakpoint in pixels\n- affects the content stacking with the vertical tabs"
        },
        "attribute": "mobile-breakpoint",
        "reflect": false,
        "defaultValue": "640"
      },
      "vertical": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "Vertical tabs"
        },
        "attribute": "vertical",
        "reflect": false,
        "defaultValue": "false"
      }
    };
  }
  static get states() {
    return {
      "isOverflowing": {},
      "isMobile": {},
      "scrollOffset": {}
    };
  }
  static get events() {
    return [{
        "method": "changeValue",
        "name": "changeValue",
        "bubbles": false,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": "Emit changes to the parent"
        },
        "complexType": {
          "original": "any",
          "resolved": "any",
          "references": {}
        }
      }];
  }
  static get elementRef() { return "el"; }
  static get watchers() {
    return [{
        "propName": "justify",
        "methodName": "onJustificationChange"
      }, {
        "propName": "value",
        "methodName": "onExternalValueChange"
      }, {
        "propName": "scrollOffset",
        "methodName": "onScrollOffsetChange"
      }];
  }
  static get listeners() {
    return [{
        "name": "tabFocus",
        "method": "tabFocusHandler",
        "target": undefined,
        "capture": false,
        "passive": true
      }, {
        "name": "tabChange",
        "method": "tabChangeHandler",
        "target": undefined,
        "capture": false,
        "passive": true
      }, {
        "name": "keydown",
        "method": "handleKeyDown",
        "target": undefined,
        "capture": true,
        "passive": false
      }, {
        "name": "keyup",
        "method": "handleKeyUp",
        "target": undefined,
        "capture": true,
        "passive": false
      }];
  }
}
CTabs._uniqueId = 0;
//# sourceMappingURL=c-tabs.js.map
