/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "./stencil-public-runtime";
import { CAlertType, CAutocompleteItem, CDataTableData, CDataTableFooterOptions, CDataTableHeader, CLoginCardBlendMode, CMenuOption, CPaginationOptions, CRadioGroupItem, CRowAlign, CRowJustify, CSelectItem, CTabsJustify, CToastMessage } from "./types";
export { CAlertType, CAutocompleteItem, CDataTableData, CDataTableFooterOptions, CDataTableHeader, CLoginCardBlendMode, CMenuOption, CPaginationOptions, CRadioGroupItem, CRowAlign, CRowJustify, CSelectItem, CTabsJustify, CToastMessage } from "./types";
export namespace Components {
    /**
     * @group Content Selectors
     */
    interface CAccordion {
        /**
          * Disallow collapsing all the items
         */
        "mandatory": boolean;
        /**
          * Allow expanding multiple items
         */
        "multiple": boolean;
        /**
          * Show an outline around expanded items
         */
        "outlined": boolean;
        /**
          * Value of the accordion
         */
        "value": number | string | (number | string)[];
    }
    /**
     * @parent c-accordion
     */
    interface CAccordionItem {
        /**
          * Marks the item as collapsable
          * @private
         */
        "collapsable": boolean;
        /**
          * Expansion status of the item
         */
        "expanded": boolean;
        /**
          * Heading of the accordion item
         */
        "heading": string;
        /**
          * Show an outline around the expanded item
          * @private
         */
        "outlined": boolean;
        /**
          * Value of the accordion item
         */
        "value": number | string;
    }
    /**
     * @group Indicators
     */
    interface CAlert {
        /**
          * Type of the alert
         */
        "type"?: CAlertType;
    }
    /**
     * @group Form
     */
    interface CAutocomplete {
        /**
          * Disable the input
         */
        "disabled": boolean;
        /**
          * Hide the hint and error messages
         */
        "hideDetails": boolean;
        /**
          * Hint text for the input
         */
        "hint": string;
        /**
          * Id of the element
         */
        "hostId": string;
        /**
          * Dropdown items
         */
        "items": CAutocompleteItem[];
        /**
          * Items per page before adding scroll
         */
        "itemsPerPage": number;
        /**
          * Element label
         */
        "label": string;
        /**
          * Show loading state
         */
        "loading": boolean;
        /**
          * Minimum query length
         */
        "minimumQueryLength": number;
        /**
          * Minimum query length message
         */
        "minimumQueryLengthMessage": string;
        /**
          * Input field name
         */
        "name": string;
        /**
          * No matching items message
         */
        "noMatchingItemsMessage": string;
        /**
          * Placeholder text
         */
        "placeholder": string;
        /**
          * Search string
         */
        "query": string;
        /**
          * Show required validation
         */
        "required": boolean;
        /**
          * Reset autocomplete state
         */
        "reset": () => Promise<void>;
        /**
          * Return object instead of value
         */
        "returnObject": boolean;
        /**
          * Shadow variant
         */
        "shadow": boolean;
        /**
          * Set the validÃ­ty of the input
         */
        "valid": boolean;
        /**
          * Manual validation
         */
        "validate": boolean;
        /**
          * Validate the input on blur
         */
        "validateOnBlur": boolean;
        /**
          * Custom validation message
         */
        "validation": string;
        /**
          * Selected item
         */
        "value": string | number | CAutocompleteItem;
    }
    /**
     * @parent none
     */
    interface CBadge {
    }
    /**
     * @group Buttons
     */
    interface CButton {
        /**
          * Danger variant style
         */
        "danger": boolean;
        /**
          * Disable the button
         */
        "disabled": boolean;
        /**
          * Fit width to containing element
         */
        "fit": boolean;
        /**
          * Light button background
         */
        "ghost": boolean;
        /**
          * True when used as a tab button
          * @private
         */
        "grouped": boolean;
        /**
          * Id of the button
         */
        "hostId": string;
        /**
          * Hyperlink url
         */
        "href": string;
        /**
          * Inverted button style for dark backgrounds
         */
        "inverted": boolean;
        /**
          * Display loader on the button
         */
        "loading": boolean;
        /**
          * Remove the default border radius
         */
        "noRadius": boolean;
        /**
          * Outlined button style
         */
        "outlined": boolean;
        /**
          * Size of the button
         */
        "size": 'default' | 'small' | 'large';
        /**
          * Used a s atab button
          * @private
         */
        "tabs": boolean;
        /**
          * Hyperlink target
         */
        "target": string;
        /**
          * Transparent button background
         */
        "text": boolean;
        /**
          * Button type
         */
        "type": 'button' | 'submit';
        /**
          * Value for the button - for use in the c-tab-buttons
         */
        "value"?: number | string;
    }
    /**
     * @group Cards
     */
    interface CCard {
        /**
          * Enter fullscreen from the outside
         */
        "enterFullscreen": () => Promise<void>;
        /**
          * Exit fullscreen from the outside
         */
        "exitFullscreen": () => Promise<void>;
        /**
          * Enable the fullscreen toggle button
         */
        "fullscreen": boolean;
    }
    /**
     * @parent c-card
     */
    interface CCardActions {
        /**
          * Align the actions
         */
        "align": 'start' | 'center' | 'end';
        /**
          * Justify the actions
         */
        "justify": | 'start'
    | 'center'
    | 'end'
    | 'space-between'
    | 'stretch'
    | 'space-around';
    }
    /**
     * @parent c-card
     */
    interface CCardContent {
    }
    /**
     * @parent c-card
     */
    interface CCardTitle {
    }
    /**
     * @group Form
     */
    interface CCheckbox {
        /**
          * If `true`, the checkbox is selected.
         */
        "checked": boolean;
        /**
          * Disable the checkbox
         */
        "disabled": boolean;
        /**
          * The value when the checkbox is unchecked
         */
        "falseValue": boolean | string;
        /**
          * Hide the hint and error messages
         */
        "hideDetails": boolean;
        /**
          * Hint text for the input
         */
        "hint": string;
        /**
          * Id of the element
         */
        "hostId": string;
        /**
          * Name of the input - Only used when the checkbox participates in a native `<form>`
         */
        "hostName": string;
        /**
          * Indeterminate state
         */
        "indeterminate": boolean;
        /**
          * Element label
         */
        "label": string;
        /**
          * Set as required
         */
        "required": boolean;
        /**
          * The value when the checkbox is checked
         */
        "trueValue": boolean | string;
        /**
          * Set the validity of the input
         */
        "valid": boolean;
        /**
          * Custom validation message
         */
        "validation": string;
        /**
          * The input value - Only used when the checkbox participates in a native `<form>`
         */
        "value": string | boolean;
    }
    /**
     * @parent c-toolbar
     */
    interface CCscLogo {
        /**
          * Logo width in pixels
         */
        "width": number;
    }
    /**
     * @group Tables
     */
    interface CDataTable {
        /**
          * Clear selections externally
         */
        "clearSelections": () => Promise<void>;
        /**
          * Data of the table
         */
        "data": CDataTableData[];
        /**
          * Externally sorted and paginated data
         */
        "externalData": boolean;
        /**
          * Items per page options
         */
        "footerOptions": CDataTableFooterOptions;
        /**
          * Provide sorted data
         */
        "getData": () => Promise<Record<string, string | number | boolean>[]>;
        /**
          * Headers of the table
         */
        "headers": CDataTableHeader[];
        /**
          * Hide the footer
         */
        "hideFooter": boolean;
        /**
          * Use horizontal scrolling
         */
        "horizontalScrolling": boolean;
        /**
          * Show a loader on top of the table
         */
        "loading": boolean;
        /**
          * Text shown when there is no data and the table is loading
         */
        "loadingText": string;
        /**
          * Text shown when there are no data available
         */
        "noDataText": string;
        /**
          * Pagination options
         */
        "pagination": CPaginationOptions;
        /**
          * Make rows selectable
         */
        "selectable": boolean;
        /**
          * Property used in selections
         */
        "selectionProperty": string;
        /**
          * Allow only a single row expanded at a time
         */
        "singleExpansion": boolean;
        /**
          * Select only a single row at a time
         */
        "singleSelection": boolean;
        /**
          * Sort data by
         */
        "sortBy": any;
        /**
          * Sorting direction
         */
        "sortDirection": 'asc' | 'desc' | null;
        /**
          * Use sticky header
         */
        "stickyHeader": boolean;
    }
    interface CDropdown {
        /**
          * Close dropdown
         */
        "close": () => Promise<void>;
        /**
          * @private
         */
        "focusItem": (index: number) => Promise<void>;
        /**
          * Id of the element
         */
        "hostId": string;
        /**
          * Current index value
         */
        "index": number;
        /**
          * Type of items
         */
        "itemType": 'option' | 'item';
        /**
          * Dropdown options
         */
        "items": | NodeListOf<HTMLCOptionElement>
    | CAutocompleteItem[]
    | CSelectItem[];
        /**
          * Items per page before adding scroll
         */
        "itemsPerPage": number;
        /**
          * Open dropdown
         */
        "open": () => Promise<void>;
        /**
          * Dropdown parent
         */
        "parent": HTMLCSelectElement | HTMLCAutocompleteElement;
        /**
          * Select item
          * @returns the disabled status of the input
         */
        "selectItem": (index: number) => Promise<boolean>;
        /**
          * @private
         */
        "setStatusText": (text: string) => Promise<void>;
        /**
          * Type of the parent element
         */
        "type": 'select' | 'autocomplete';
        /**
          * Update list items
         */
        "updateList": () => Promise<void>;
    }
    /**
     * @group Other
     */
    interface CIcon {
        /**
          * Fill color
         */
        "color": string;
        /**
          * Svg path d attribute value
         */
        "path": string;
        /**
          * Icon size in pixels
         */
        "size": number;
    }
    /**
     * @group Buttons
     */
    interface CIconButton {
        /**
          * Show a badge on top of the icon
         */
        "badge": string;
        /**
          * Danger variant of the button
         */
        "danger": boolean;
        /**
          * Disable the button
         */
        "disabled": boolean;
        /**
          * Ghost variant of the button
         */
        "ghost": boolean;
        /**
          * Inverted color for dark backgrounds
         */
        "inverted": boolean;
        /**
          * Loading variant of the button
         */
        "loading": boolean;
        /**
          * Outlined variant of the button
         */
        "outlined": boolean;
        /**
          * Path for the svg icon
         */
        "path": string;
        /**
          * Size of the button
         */
        "size": 'default' | 'x-small' | 'small';
        /**
          * Text variant of the button
         */
        "text": boolean;
    }
    /**
     * @parent None
     */
    interface CInput {
        /**
          * Active state
         */
        "active": boolean;
        /**
          * Auto focus the input
         */
        "autofocus": boolean;
        /**
          * Disable the input
         */
        "disabled": boolean;
        /**
          * Render a hidden input outside the shadow dom
         */
        "form": boolean;
        /**
          * Hide the hint and error messages
         */
        "hideDetails": boolean;
        /**
          * Hint text for the input
         */
        "hint": string;
        /**
          * Id of the input
         */
        "hostId": string;
        /**
          * Id of the input element
         */
        "inputId": string;
        /**
          * Items for the dropdown
         */
        "items": CSelectItem[];
        /**
          * Items per page before adding scroll
         */
        "itemsPerPage": number;
        /**
          * Label of the input
         */
        "label": string;
        /**
          * Maximum value on a numeric input
         */
        "max": number;
        /**
          * Minimum value on a numeric input
         */
        "min": number;
        /**
          * Name of the input
         */
        "name": string;
        /**
          * Placeholder of the input
         */
        "placeholder": string;
        /**
          * Mark as readonly
         */
        "readonly": boolean;
        /**
          * Set the input as required
         */
        "required": boolean;
        /**
          * @private
         */
        "reset": () => Promise<void>;
        /**
          * Rows on the input
         */
        "rows": number;
        /**
          * Shadow variant of the input
         */
        "shadow": boolean;
        /**
          * Step size on a numeric input
         */
        "step": number;
        /**
          * Type of the input
         */
        "type": string;
        /**
          * Set the validÃ­ty of the input
         */
        "valid": boolean;
        /**
          * Manual validation
         */
        "validate": boolean;
        /**
          * Validate the input on blur
         */
        "validateOnBlur": boolean;
        /**
          * Custom validation message
         */
        "validation": string;
        /**
          * Value of the input
         */
        "value": string | number | boolean | CSelectItem | CAutocompleteItem;
        /**
          * Variant
         */
        "variant": 'text' | 'select';
    }
    /**
     * Basic hyperlink component
     * @group Buttons
     */
    interface CLink {
        /**
          * Url of link
         */
        "href": string;
        /**
          * regular target attribute of a hyperlink
         */
        "target": string;
        /**
          * Display line under the link
         */
        "underline": boolean;
        /**
          * Customisable font weight
         */
        "weight": string;
    }
    /**
     * @group Other
     */
    interface CList {
        /**
          * Disable the list
         */
        "disabled": boolean;
    }
    interface CListItem {
        /**
          * Set the item active
         */
        "active": boolean;
        /**
          * Disable the item
         */
        "disabled": boolean;
        /**
          * Disabled by the parent list
          * @private
         */
        "disabledByParent": boolean;
        /**
          * Display background color on hover
         */
        "hoverable": boolean;
        /**
          * Hyperlink url
         */
        "href"?: string;
        /**
          * Add ripple effect to the item
         */
        "ripple": boolean;
        /**
          * Hyperlink target
         */
        "target": string;
    }
    interface CListItemTitle {
        /**
          * Set the title active
         */
        "active": boolean;
    }
    /**
     * A loader component that fills the nearest containing element that has css-property position set to 'relative'
     * @group Indicators
     */
    interface CLoader {
        /**
          * Delay in seconds of showing the contents in the slot of the loader
         */
        "contentdelay": number;
        /**
          * Hide the loader
         */
        "hide": boolean;
        /**
          * Size of the loader
         */
        "size": number;
        /**
          * Width of the loader
         */
        "width": number;
    }
    /**
     * @parent c-login-buttons
     */
    interface CLoginButton {
        /**
          * Alt description for logo
         */
        "alt": string;
        /**
          * Login provider link. Do not set if using a javascript click handler
         */
        "href"?: string;
        /**
          * Login provider logo url
         */
        "src": string;
    }
    /**
     * @group buttons
     */
    interface CLoginButtons {
    }
    /**
     * @group Cards
     */
    interface CLoginCard {
        /**
          * Background position (css background-position)
         */
        "backgroundPosition": string;
        /**
          * Mobile breakpoint in pixels
         */
        "mobileBreakpoint": number;
        /**
          * Add colored overlay to the background image
         */
        "overlay": boolean;
        /**
          * Add colored overlay to the background image
         */
        "overlayBlendMode": CLoginCardBlendMode;
        /**
          * Background image
         */
        "src": string;
    }
    /**
     * @parent c-login-card
     */
    interface CLoginCardActions {
        /**
          * Align the actions
         */
        "align": 'start' | 'center' | 'end';
        /**
          * Justify the actions
         */
        "justify": | 'start'
    | 'center'
    | 'end'
    | 'space-between'
    | 'stretch'
    | 'space-around';
    }
    /**
     * @parent c-login-card
     */
    interface CLoginCardContent {
    }
    /**
     * @parent c-login-card
     */
    interface CLoginCardTitle {
    }
    /**
     * Wrapper component for the whole page
     * @group Layout
     */
    interface CMain {
        /**
          * Disable the default dashboard layout
         */
        "disableLayout": boolean;
    }
    /**
     * @group Navigation
     */
    interface CMenu {
        /**
          * Menu content css class
         */
        "contentClass": string;
        /**
          * No chevron and background, E.g. when a button is the activator
         */
        "custom": boolean;
        /**
          * No hover background
         */
        "flat": boolean;
        /**
          * Menu items
         */
        "items": CMenuOption[];
        /**
          * Items per page before adding scroll
         */
        "itemsPerPage": number;
        /**
          * Small variant
         */
        "small": boolean;
    }
    /**
     * @parent c-menu
     */
    interface CMenuItems {
        /**
          * Menu is opened and positioned
          * @private
         */
        "active": boolean;
        /**
          * is active
          * @private
         */
        "index": number | null;
        /**
          * Menu items
          * @private
         */
        "items": CMenuOption[];
        /**
          * Items per page before adding scroll
          * @private
         */
        "itemsPerPage": number;
        /**
          * Menu parent
          * @private
         */
        "parent": HTMLCMenuElement;
        /**
          * Type of parent
          * @private
         */
        "parentType": string;
        /**
          * Small variant
          * @private
         */
        "small": boolean;
        /**
          * Initial top position
          * @private
         */
        "top": number;
    }
    /**
     * @parent None
     */
    interface CMessage {
        /**
          * Hint text for the input
         */
        "hint": string;
        /**
          * Id of the related input element
         */
        "inputId": string;
        /**
          * Parent validÃ­ty
         */
        "valid": boolean;
        /**
          * Custom validation message
         */
        "validation": string;
    }
    /**
     * @group Popups
     */
    interface CModal {
        /**
          * Disable backdrop blur effect
         */
        "disableBackdropBlur": boolean;
        /**
          * Dismissed when touching/clicking outside the content
         */
        "dismissable": boolean;
        /**
          * Is the modal visible
         */
        "value": boolean;
        /**
          * Width of the dialog. Numeric value is considered as pixel value (400 -> 400px)
         */
        "width": string | number;
        /**
          * Z-index of the modal
         */
        "zIndex": number;
    }
    /**
     * @parent c-toolbar
     */
    interface CNavigationButton {
    }
    /**
     * @parent c-select
     */
    interface COption {
        /**
          * Set option as disabled
         */
        "disabled": boolean;
        /**
          * Option name
         */
        "name": string;
        /**
          * Set option as selected
         */
        "selected": boolean;
        /**
          * Option value
         */
        "value": string | number;
    }
    interface COptionValue {
    }
    /**
     * @group Form
     */
    interface COtpInput {
        /**
          * Id of the element
         */
        "elementId": string;
        /**
          * Hide the hint and error messages
         */
        "hideDetails": boolean;
        /**
          * Hint text for the input
         */
        "hint": string;
        /**
          * Length of the OTP code
         */
        "length": number;
        /**
          * Reset input value
         */
        "reset": () => Promise<void>;
        /**
          * Set the validÃ­ty of the input
         */
        "valid": boolean;
        /**
          * Custom validation message
         */
        "validation": string;
        /**
          * Value of the input
         */
        "value": string;
    }
    /**
     * @group Layout
     */
    interface CPage {
        /**
          * Display scroll indicator
         */
        "scrollIndicator": boolean;
    }
    /**
     * @group Navigation
     */
    interface CPagination {
        /**
          * Hide details (per page dropdown and the 'x - y of n pages' text)
         */
        "hideDetails": boolean;
        /**
          * Hide range indicator
         */
        "hideRange": boolean;
        /**
          * Hide page number buttons
         */
        "simple": boolean;
        /**
          * Hide details (per page dropdown and the 'x - y of n pages' text)
         */
        "size": 'default' | 'small';
        /**
          * Object containing values that are needed for pagination.  Note! startFrom and endTo are assigned automatically to the object based on other values
         */
        "value": CPaginationOptions;
    }
    /**
     * @group Indicators
     */
    interface CProgressBar {
        /**
          * Hide the percentage display
         */
        "hideDetails": boolean;
        /**
          * Indeterminate state of the progress bar
         */
        "indeterminate": boolean;
        /**
          * Optional details message next to percentage display
         */
        "label": string;
        /**
          * Place details next to progress bar
         */
        "singleLine": boolean;
        /**
          * Progress bar value in percentage (0 to 100)
         */
        "value": number;
    }
    /**
     * @parent c-radio-group
     */
    interface CRadio {
        /**
          * Set option as checked
         */
        "checked": boolean;
        /**
          * Disable the radio button
         */
        "disabled": boolean;
        /**
          * Radio button value
         */
        "value": string;
    }
    /**
     * @group Form
     */
    interface CRadioGroup {
        /**
          * Color of the radio group
         */
        "color": string;
        /**
          * Disable the radio group
         */
        "disabled": boolean;
        /**
          * Hide the hint and error messages
         */
        "hideDetails": boolean;
        /**
          * Hint text for the input
         */
        "hint": string;
        /**
          * Id of the element
         */
        "hostId": string;
        /**
          * Display radio buttons inline
         */
        "inline": boolean;
        /**
          * Radio group items
         */
        "items": CRadioGroupItem[];
        /**
          * Label of the radio group
         */
        "label": string;
        /**
          * Set as required
         */
        "required": boolean;
        /**
          * Return the whole item object
         */
        "returnObject": boolean;
        /**
          * Set the validity of the input
         */
        "valid": boolean;
        /**
          * Custom validation message
         */
        "validation": string;
        /**
          * Value of the radio group
         */
        "value": string | number | CRadioGroupItem;
    }
    /**
     * @parent None
     */
    interface CRipple {
        /**
          * Creates a ripple
         */
        "createRipple": (event: MouseEvent, parent: HTMLElement, center?: boolean) => Promise<void>;
    }
    /**
     * Generic flex row component
     * @group Layout
     */
    interface CRow {
        /**
          * Align items vertically
         */
        "align": CRowAlign;
        /**
          * Gap between items in px
         */
        "gap": number;
        /**
          * Justify content horizontally
         */
        "justify": CRowJustify;
        /**
          * Disable flex wrap
         */
        "nowrap": boolean;
    }
    /**
     * @group Form
     */
    interface CSelect {
        /**
          * Make the selected value clearable
         */
        "clearable": boolean;
        /**
          * Disable the input
         */
        "disabled": boolean;
        /**
          * Hide the hint and error messages
         */
        "hideDetails": boolean;
        /**
          * Hint text for the input
         */
        "hint": string;
        /**
          * Id of the element
         */
        "hostId": string;
        /**
          * Dropdown items
         */
        "items": CSelectItem[];
        /**
          * Items per page before adding scroll
         */
        "itemsPerPage": number;
        /**
          * Element label
         */
        "label": string;
        /**
          * Show loading state
         */
        "loading": boolean;
        /**
          * Input field name
         */
        "name": string;
        /**
          * display the option as selection (works only when c-option elements are used)
         */
        "optionAsSelection": false;
        /**
          * Placeholder text
         */
        "placeholder": string;
        /**
          * Show required validation
         */
        "required": boolean;
        /**
          * Reset select state
         */
        "reset": () => Promise<void>;
        /**
          * Return object instead of value
         */
        "returnObject": boolean;
        /**
          * Shadow variant
         */
        "shadow": boolean;
        /**
          * Set the validÃ­ty of the input
         */
        "valid": boolean;
        /**
          * Manual validation
         */
        "validate": boolean;
        /**
          * Validate the input on blur
         */
        "validateOnBlur": boolean;
        /**
          * Custom validation message
         */
        "validation": string;
        /**
          * Selected item
         */
        "value": string | number | CSelectItem;
    }
    /**
     * @group Navigation
     */
    interface CSideNavigation {
        /**
          * Mobile version menu visibility
         */
        "menuVisible": boolean;
        /**
          * Mobile version
         */
        "mobile": boolean;
    }
    /**
     * @parent c-side-navigation
     */
    interface CSideNavigationItem {
        /**
          * Indicate active state
         */
        "active": boolean;
        /**
          * Hyperlink url
         */
        "href": string;
        /**
          * Loading state
         */
        "loading": boolean;
        /**
          * Hyperlink target
         */
        "target": string;
    }
    /**
     * @parent c-side-navigation
     */
    interface CSideNavigationTitle {
    }
    /**
     * @group Form
     */
    interface CSlider {
        /**
          * Aria label
         */
        "ariaLabel": string;
        /**
          * Disable tooltip
         */
        "disableTooltip": boolean;
        /**
          * Disable the slider
         */
        "disabled": boolean;
        /**
          * Id of the element
         */
        "hostId": string;
        /**
          * Id of the element
         */
        "hostName": string;
        /**
          * Label of the slider
         */
        "label": string;
        /**
          * Show tick labels
         */
        "labels": boolean;
        /**
          * Max value
         */
        "max": string;
        /**
          * Min value
         */
        "min": string;
        /**
          * Segment count
         */
        "segments": string;
        /**
          * Step
         */
        "step": string;
        /**
          * Thow ticks
         */
        "ticks": boolean;
        /**
          * Unit
         */
        "unit": string;
        /**
          * Value
         */
        "value": string | number;
    }
    /**
     * Spacer component for flex containers
     * @group Layout
     */
    interface CSpacer {
    }
    /**
     * @group indicators
     */
    interface CSpinner {
        /**
          * Color of the spinner
         */
        "color": string;
        /**
          * Size of the spinner
         */
        "size": number;
        /**
          * Width of the spinner
         */
        "width": number;
    }
    /**
     * @group Indicators
     */
    interface CStatus {
        /**
          * Status type
         */
        "type"?: 'info' | 'warning' | 'error' | 'success';
    }
    /**
     * @group Indicators
     * @parent c-steps
     */
    interface CStep {
        /**
          * Mark step as complete
          * @private
         */
        "complete": boolean;
        /**
          * Mark step as current
          * @private
         */
        "current": boolean;
    }
    /**
     * @group Indicators
     */
    interface CSteps {
        /**
          * Value of the accordion (current step number)
         */
        "value": number | string;
    }
    /**
     * @parent c-side-navigation
     */
    interface CSubNavigationItem {
        /**
          * Active state
         */
        "active": boolean;
        /**
          * Element is visible and focusable
         */
        "focusable": boolean;
        /**
          * Link url
         */
        "href": string;
        /**
          * Loading state
         */
        "loading": boolean;
        /**
          * Link target
         */
        "target": string;
    }
    /**
     * @group Content Selectors
     */
    interface CSwiper {
        /**
          * Id of the swiper element
         */
        "elementId": string;
        /**
          * Value of the swiper
         */
        "value": number | string;
    }
    /**
     * @parent c-swiper
     */
    interface CSwiperTab {
        /**
          * Mark as active
         */
        "active": boolean;
        /**
          * Disable button
         */
        "disabled": boolean;
        /**
          * Id of the button
         */
        "hostId": string;
        /**
          * Label of the button
         */
        "label": string;
        /**
          * Position in the set
          * @private
         */
        "position": number;
        /**
          * Size of the set
          * @private
         */
        "setsize": number;
        /**
          * Value of the button
         */
        "value": number | string;
    }
    /**
     * @group Form
     */
    interface CSwitch {
        /**
          * If `true`, the checkbox is selected.
         */
        "checked": boolean;
        /**
          * The value when the checkbox is unchecked
         */
        "falseValue": boolean | string;
        /**
          * Disable the switch
         */
        "hostDisabled": boolean;
        /**
          * Id for the element
         */
        "hostId": string;
        /**
          * Set as required
         */
        "required": boolean;
        /**
          * The value when the checkbox is checked
         */
        "trueValue": boolean | string;
        /**
          * The input value - Only used when the checkbox participates in a native `<form>`
         */
        "value": string | boolean;
    }
    /**
     * @group Tabs
     * @parent c-tabs
     */
    interface CTab {
        /**
          * Mark tab as active
         */
        "active": boolean;
        /**
          * Mark tab as disabled
         */
        "disabled": boolean;
        /**
          * Id of the tab
         */
        "hostId": string;
        /**
          * Position in the set
          * @private
         */
        "position": number;
        /**
          * Size of the set
          * @private
         */
        "setsize": number;
        /**
          * Value for the tab - for use in c-tabs
         */
        "value"?: number | string;
    }
    /**
     * @group Content Selectors
     */
    interface CTabButtons {
        /**
          * Disable tab buttons
         */
        "hostDisabled": boolean;
        /**
          * Always require a selection
         */
        "mandatory": boolean;
        /**
          * Size of the buttons
         */
        "size": 'default' | 'small';
        /**
          * Used as controller for c-tabs
          * @private
         */
        "tabs": boolean;
        /**
          * Value of tab buttons
         */
        "value": number | string;
    }
    /**
     * @parent c-tabs
     */
    interface CTabItem {
        /**
          * Active
          * @private
         */
        "active": boolean;
        /**
          * Tab value
         */
        "value": number | string;
    }
    /**
     * @parent c-tabs
     */
    interface CTabItems {
        /**
          * Disable animation
          * @private
         */
        "disableAnimation": boolean;
        /**
          * Currently active tab
         */
        "value": number | string;
    }
    /**
     * @group tables
     */
    interface CTable {
        /**
          * Mobile breakpoint in pixels
         */
        "mobileBreakpoint": number;
        /**
          * Should the table be responsive
         */
        "responsive": boolean;
    }
    /**
     * @group Content Selectors
     */
    interface CTabs {
        /**
          * Disable the bottom border
         */
        "borderless": boolean;
        /**
          * Disable animation
         */
        "disableAnimation": boolean;
        /**
          * Justification of the children
         */
        "justify": CTabsJustify;
        /**
          * Mobile breakpoint in pixels - affects the content stacking with the vertical tabs
         */
        "mobileBreakpoint": number;
        /**
          * Currently active tab
         */
        "value": number | string;
        /**
          * Vertical tabs
         */
        "vertical": boolean;
    }
    /**
     * @parent c-tags
     */
    interface CTag {
        /**
          * Mark tag as active
         */
        "active": boolean;
        /**
          * Display an optional badge at the start of the tag
         */
        "badge": string | number;
        /**
          * Stretch to fill the container row
         */
        "block": boolean;
        /**
          * Mark tag as closeable
         */
        "closeable": boolean;
        /**
          * Stretch to fill the container
         */
        "fit": boolean;
        /**
          * Remove the hover effect
         */
        "flat": boolean;
        /**
          * Size of the tag
         */
        "size": 'default' | 'small';
    }
    /**
     * @group buttons
     */
    interface CTags {
        /**
          * Size of the tags
         */
        "size": 'default' | 'small';
    }
    /**
     * @group Form
     */
    interface CTextField {
        /**
          * HTML input autocapitalize
         */
        "autocapitalize": string;
        /**
          * HTML input autocomplete
         */
        "autocomplete": string;
        /**
          * HTML input autocorrect
         */
        "autocorrect": string;
        /**
          * Auto focus the input
         */
        "autofocus": boolean;
        /**
          * Disable the input
         */
        "disabled": boolean;
        /**
          * Hide the hint and error messages
         */
        "hideDetails": boolean;
        /**
          * Hint text for the input
         */
        "hint": string;
        /**
          * Id of the input
         */
        "hostId": string;
        /**
          * Label of the input
         */
        "label": string;
        /**
          * Maximum value on a numeric input
         */
        "max": number;
        /**
          * Minimum value on a numeric input
         */
        "min": number;
        /**
          * Name of the input
         */
        "name": string;
        /**
          * Placeholder of the input
         */
        "placeholder": string;
        /**
          * Mark as readonly
         */
        "readonly": boolean;
        /**
          * Set the input as required
         */
        "required": boolean;
        /**
          * Rows on the input
         */
        "rows": number;
        /**
          * Shadow variant of the input
         */
        "shadow": boolean;
        /**
          * Step size on a numeric input
         */
        "step": number;
        /**
          * Trim whitespace from the return value
         */
        "trimWhitespace": boolean;
        /**
          * Type of the input
         */
        "type": string;
        /**
          * Set the validity of the input
         */
        "valid": boolean;
        /**
          * Manual validation
         */
        "validate": boolean;
        /**
          * Validate the input on blur
         */
        "validateOnBlur": boolean;
        /**
          * Custom validation message
         */
        "validation": string;
        /**
          * Value of the input
         */
        "value": string;
    }
    /**
     * @parent none
     */
    interface CToast {
        /**
          * Close toast
          * @emits close
         */
        "closeToast": () => Promise<void>;
        /**
          * Messages
         */
        "message": CToastMessage;
    }
    /**
     * @group Popups
     */
    interface CToasts {
        /**
          * Use absolute positioning
         */
        "absolute": boolean;
        /**
          * Add a new message
         */
        "addToast": (message: CToastMessage) => Promise<void>;
        /**
          * Horizontal position
         */
        "horizontal": 'left' | 'center' | 'right';
        /**
          * Remove a message by id (id should be specified in the addToast params)
         */
        "removeToast": (id: string) => Promise<void>;
        /**
          * Vertical position
         */
        "vertical": 'top' | 'bottom';
    }
    /**
     * @group Navigation
     */
    interface CToolbar {
    }
}
export interface CAccordionCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLCAccordionElement;
}
export interface CAccordionItemCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLCAccordionItemElement;
}
export interface CAutocompleteCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLCAutocompleteElement;
}
export interface CButtonCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLCButtonElement;
}
export interface CCheckboxCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLCCheckboxElement;
}
export interface CDataTableCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLCDataTableElement;
}
export interface CDropdownCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLCDropdownElement;
}
export interface CInputCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLCInputElement;
}
export interface CMenuItemsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLCMenuItemsElement;
}
export interface CModalCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLCModalElement;
}
export interface COtpInputCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLCOtpInputElement;
}
export interface CPaginationCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLCPaginationElement;
}
export interface CRadioGroupCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLCRadioGroupElement;
}
export interface CSelectCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLCSelectElement;
}
export interface CSideNavigationItemCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLCSideNavigationItemElement;
}
export interface CSliderCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLCSliderElement;
}
export interface CStepsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLCStepsElement;
}
export interface CSwiperCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLCSwiperElement;
}
export interface CSwiperTabCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLCSwiperTabElement;
}
export interface CSwitchCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLCSwitchElement;
}
export interface CTabCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLCTabElement;
}
export interface CTabButtonsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLCTabButtonsElement;
}
export interface CTabItemCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLCTabItemElement;
}
export interface CTabsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLCTabsElement;
}
export interface CTagCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLCTagElement;
}
export interface CTextFieldCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLCTextFieldElement;
}
export interface CToastCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLCToastElement;
}
declare global {
    interface HTMLCAccordionElementEventMap {
        "changeValue": number | string;
    }
    /**
     * @group Content Selectors
     */
    interface HTMLCAccordionElement extends Components.CAccordion, HTMLStencilElement {
        addEventListener<K extends keyof HTMLCAccordionElementEventMap>(type: K, listener: (this: HTMLCAccordionElement, ev: CAccordionCustomEvent<HTMLCAccordionElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLCAccordionElementEventMap>(type: K, listener: (this: HTMLCAccordionElement, ev: CAccordionCustomEvent<HTMLCAccordionElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLCAccordionElement: {
        prototype: HTMLCAccordionElement;
        new (): HTMLCAccordionElement;
    };
    interface HTMLCAccordionItemElementEventMap {
        "itemChange": any;
    }
    /**
     * @parent c-accordion
     */
    interface HTMLCAccordionItemElement extends Components.CAccordionItem, HTMLStencilElement {
        addEventListener<K extends keyof HTMLCAccordionItemElementEventMap>(type: K, listener: (this: HTMLCAccordionItemElement, ev: CAccordionItemCustomEvent<HTMLCAccordionItemElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLCAccordionItemElementEventMap>(type: K, listener: (this: HTMLCAccordionItemElement, ev: CAccordionItemCustomEvent<HTMLCAccordionItemElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLCAccordionItemElement: {
        prototype: HTMLCAccordionItemElement;
        new (): HTMLCAccordionItemElement;
    };
    /**
     * @group Indicators
     */
    interface HTMLCAlertElement extends Components.CAlert, HTMLStencilElement {
    }
    var HTMLCAlertElement: {
        prototype: HTMLCAlertElement;
        new (): HTMLCAlertElement;
    };
    interface HTMLCAutocompleteElementEventMap {
        "changeQuery": any;
        "changeValue": any;
    }
    /**
     * @group Form
     */
    interface HTMLCAutocompleteElement extends Components.CAutocomplete, HTMLStencilElement {
        addEventListener<K extends keyof HTMLCAutocompleteElementEventMap>(type: K, listener: (this: HTMLCAutocompleteElement, ev: CAutocompleteCustomEvent<HTMLCAutocompleteElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLCAutocompleteElementEventMap>(type: K, listener: (this: HTMLCAutocompleteElement, ev: CAutocompleteCustomEvent<HTMLCAutocompleteElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLCAutocompleteElement: {
        prototype: HTMLCAutocompleteElement;
        new (): HTMLCAutocompleteElement;
    };
    /**
     * @parent none
     */
    interface HTMLCBadgeElement extends Components.CBadge, HTMLStencilElement {
    }
    var HTMLCBadgeElement: {
        prototype: HTMLCBadgeElement;
        new (): HTMLCBadgeElement;
    };
    interface HTMLCButtonElementEventMap {
        "tabChange": {
    value: number | string;
    element: HTMLCButtonElement;
  };
        "tabFocus": number | string;
    }
    /**
     * @group Buttons
     */
    interface HTMLCButtonElement extends Components.CButton, HTMLStencilElement {
        addEventListener<K extends keyof HTMLCButtonElementEventMap>(type: K, listener: (this: HTMLCButtonElement, ev: CButtonCustomEvent<HTMLCButtonElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLCButtonElementEventMap>(type: K, listener: (this: HTMLCButtonElement, ev: CButtonCustomEvent<HTMLCButtonElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLCButtonElement: {
        prototype: HTMLCButtonElement;
        new (): HTMLCButtonElement;
    };
    /**
     * @group Cards
     */
    interface HTMLCCardElement extends Components.CCard, HTMLStencilElement {
    }
    var HTMLCCardElement: {
        prototype: HTMLCCardElement;
        new (): HTMLCCardElement;
    };
    /**
     * @parent c-card
     */
    interface HTMLCCardActionsElement extends Components.CCardActions, HTMLStencilElement {
    }
    var HTMLCCardActionsElement: {
        prototype: HTMLCCardActionsElement;
        new (): HTMLCCardActionsElement;
    };
    /**
     * @parent c-card
     */
    interface HTMLCCardContentElement extends Components.CCardContent, HTMLStencilElement {
    }
    var HTMLCCardContentElement: {
        prototype: HTMLCCardContentElement;
        new (): HTMLCCardContentElement;
    };
    /**
     * @parent c-card
     */
    interface HTMLCCardTitleElement extends Components.CCardTitle, HTMLStencilElement {
    }
    var HTMLCCardTitleElement: {
        prototype: HTMLCCardTitleElement;
        new (): HTMLCCardTitleElement;
    };
    interface HTMLCCheckboxElementEventMap {
        "changeValue": any;
    }
    /**
     * @group Form
     */
    interface HTMLCCheckboxElement extends Components.CCheckbox, HTMLStencilElement {
        addEventListener<K extends keyof HTMLCCheckboxElementEventMap>(type: K, listener: (this: HTMLCCheckboxElement, ev: CCheckboxCustomEvent<HTMLCCheckboxElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLCCheckboxElementEventMap>(type: K, listener: (this: HTMLCCheckboxElement, ev: CCheckboxCustomEvent<HTMLCCheckboxElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLCCheckboxElement: {
        prototype: HTMLCCheckboxElement;
        new (): HTMLCCheckboxElement;
    };
    /**
     * @parent c-toolbar
     */
    interface HTMLCCscLogoElement extends Components.CCscLogo, HTMLStencilElement {
    }
    var HTMLCCscLogoElement: {
        prototype: HTMLCCscLogoElement;
        new (): HTMLCCscLogoElement;
    };
    interface HTMLCDataTableElementEventMap {
        "paginate": CPaginationOptions;
        "expand": any;
        "sort": any;
        "selection": any;
    }
    /**
     * @group Tables
     */
    interface HTMLCDataTableElement extends Components.CDataTable, HTMLStencilElement {
        addEventListener<K extends keyof HTMLCDataTableElementEventMap>(type: K, listener: (this: HTMLCDataTableElement, ev: CDataTableCustomEvent<HTMLCDataTableElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLCDataTableElementEventMap>(type: K, listener: (this: HTMLCDataTableElement, ev: CDataTableCustomEvent<HTMLCDataTableElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLCDataTableElement: {
        prototype: HTMLCDataTableElement;
        new (): HTMLCDataTableElement;
    };
    interface HTMLCDropdownElementEventMap {
        "selectOption": any;
        "dropdownStateChange": boolean;
    }
    interface HTMLCDropdownElement extends Components.CDropdown, HTMLStencilElement {
        addEventListener<K extends keyof HTMLCDropdownElementEventMap>(type: K, listener: (this: HTMLCDropdownElement, ev: CDropdownCustomEvent<HTMLCDropdownElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLCDropdownElementEventMap>(type: K, listener: (this: HTMLCDropdownElement, ev: CDropdownCustomEvent<HTMLCDropdownElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLCDropdownElement: {
        prototype: HTMLCDropdownElement;
        new (): HTMLCDropdownElement;
    };
    /**
     * @group Other
     */
    interface HTMLCIconElement extends Components.CIcon, HTMLStencilElement {
    }
    var HTMLCIconElement: {
        prototype: HTMLCIconElement;
        new (): HTMLCIconElement;
    };
    /**
     * @group Buttons
     */
    interface HTMLCIconButtonElement extends Components.CIconButton, HTMLStencilElement {
    }
    var HTMLCIconButtonElement: {
        prototype: HTMLCIconButtonElement;
        new (): HTMLCIconButtonElement;
    };
    interface HTMLCInputElementEventMap {
        "changeValue": any;
        "itemClick": any;
        "dropdownClose": any;
    }
    /**
     * @parent None
     */
    interface HTMLCInputElement extends Components.CInput, HTMLStencilElement {
        addEventListener<K extends keyof HTMLCInputElementEventMap>(type: K, listener: (this: HTMLCInputElement, ev: CInputCustomEvent<HTMLCInputElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLCInputElementEventMap>(type: K, listener: (this: HTMLCInputElement, ev: CInputCustomEvent<HTMLCInputElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLCInputElement: {
        prototype: HTMLCInputElement;
        new (): HTMLCInputElement;
    };
    /**
     * Basic hyperlink component
     * @group Buttons
     */
    interface HTMLCLinkElement extends Components.CLink, HTMLStencilElement {
    }
    var HTMLCLinkElement: {
        prototype: HTMLCLinkElement;
        new (): HTMLCLinkElement;
    };
    /**
     * @group Other
     */
    interface HTMLCListElement extends Components.CList, HTMLStencilElement {
    }
    var HTMLCListElement: {
        prototype: HTMLCListElement;
        new (): HTMLCListElement;
    };
    interface HTMLCListItemElement extends Components.CListItem, HTMLStencilElement {
    }
    var HTMLCListItemElement: {
        prototype: HTMLCListItemElement;
        new (): HTMLCListItemElement;
    };
    interface HTMLCListItemTitleElement extends Components.CListItemTitle, HTMLStencilElement {
    }
    var HTMLCListItemTitleElement: {
        prototype: HTMLCListItemTitleElement;
        new (): HTMLCListItemTitleElement;
    };
    /**
     * A loader component that fills the nearest containing element that has css-property position set to 'relative'
     * @group Indicators
     */
    interface HTMLCLoaderElement extends Components.CLoader, HTMLStencilElement {
    }
    var HTMLCLoaderElement: {
        prototype: HTMLCLoaderElement;
        new (): HTMLCLoaderElement;
    };
    /**
     * @parent c-login-buttons
     */
    interface HTMLCLoginButtonElement extends Components.CLoginButton, HTMLStencilElement {
    }
    var HTMLCLoginButtonElement: {
        prototype: HTMLCLoginButtonElement;
        new (): HTMLCLoginButtonElement;
    };
    /**
     * @group buttons
     */
    interface HTMLCLoginButtonsElement extends Components.CLoginButtons, HTMLStencilElement {
    }
    var HTMLCLoginButtonsElement: {
        prototype: HTMLCLoginButtonsElement;
        new (): HTMLCLoginButtonsElement;
    };
    /**
     * @group Cards
     */
    interface HTMLCLoginCardElement extends Components.CLoginCard, HTMLStencilElement {
    }
    var HTMLCLoginCardElement: {
        prototype: HTMLCLoginCardElement;
        new (): HTMLCLoginCardElement;
    };
    /**
     * @parent c-login-card
     */
    interface HTMLCLoginCardActionsElement extends Components.CLoginCardActions, HTMLStencilElement {
    }
    var HTMLCLoginCardActionsElement: {
        prototype: HTMLCLoginCardActionsElement;
        new (): HTMLCLoginCardActionsElement;
    };
    /**
     * @parent c-login-card
     */
    interface HTMLCLoginCardContentElement extends Components.CLoginCardContent, HTMLStencilElement {
    }
    var HTMLCLoginCardContentElement: {
        prototype: HTMLCLoginCardContentElement;
        new (): HTMLCLoginCardContentElement;
    };
    /**
     * @parent c-login-card
     */
    interface HTMLCLoginCardTitleElement extends Components.CLoginCardTitle, HTMLStencilElement {
    }
    var HTMLCLoginCardTitleElement: {
        prototype: HTMLCLoginCardTitleElement;
        new (): HTMLCLoginCardTitleElement;
    };
    /**
     * Wrapper component for the whole page
     * @group Layout
     */
    interface HTMLCMainElement extends Components.CMain, HTMLStencilElement {
    }
    var HTMLCMainElement: {
        prototype: HTMLCMainElement;
        new (): HTMLCMainElement;
    };
    /**
     * @group Navigation
     */
    interface HTMLCMenuElement extends Components.CMenu, HTMLStencilElement {
    }
    var HTMLCMenuElement: {
        prototype: HTMLCMenuElement;
        new (): HTMLCMenuElement;
    };
    interface HTMLCMenuItemsElementEventMap {
        "close": any;
        "open": {
    height: number;
    width: number;
    isInView: {
      x: boolean;
      y: boolean;
    };
  };
    }
    /**
     * @parent c-menu
     */
    interface HTMLCMenuItemsElement extends Components.CMenuItems, HTMLStencilElement {
        addEventListener<K extends keyof HTMLCMenuItemsElementEventMap>(type: K, listener: (this: HTMLCMenuItemsElement, ev: CMenuItemsCustomEvent<HTMLCMenuItemsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLCMenuItemsElementEventMap>(type: K, listener: (this: HTMLCMenuItemsElement, ev: CMenuItemsCustomEvent<HTMLCMenuItemsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLCMenuItemsElement: {
        prototype: HTMLCMenuItemsElement;
        new (): HTMLCMenuItemsElement;
    };
    /**
     * @parent None
     */
    interface HTMLCMessageElement extends Components.CMessage, HTMLStencilElement {
    }
    var HTMLCMessageElement: {
        prototype: HTMLCMessageElement;
        new (): HTMLCMessageElement;
    };
    interface HTMLCModalElementEventMap {
        "changeValue": boolean;
    }
    /**
     * @group Popups
     */
    interface HTMLCModalElement extends Components.CModal, HTMLStencilElement {
        addEventListener<K extends keyof HTMLCModalElementEventMap>(type: K, listener: (this: HTMLCModalElement, ev: CModalCustomEvent<HTMLCModalElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLCModalElementEventMap>(type: K, listener: (this: HTMLCModalElement, ev: CModalCustomEvent<HTMLCModalElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLCModalElement: {
        prototype: HTMLCModalElement;
        new (): HTMLCModalElement;
    };
    /**
     * @parent c-toolbar
     */
    interface HTMLCNavigationButtonElement extends Components.CNavigationButton, HTMLStencilElement {
    }
    var HTMLCNavigationButtonElement: {
        prototype: HTMLCNavigationButtonElement;
        new (): HTMLCNavigationButtonElement;
    };
    /**
     * @parent c-select
     */
    interface HTMLCOptionElement extends Components.COption, HTMLStencilElement {
    }
    var HTMLCOptionElement: {
        prototype: HTMLCOptionElement;
        new (): HTMLCOptionElement;
    };
    interface HTMLCOptionValueElement extends Components.COptionValue, HTMLStencilElement {
    }
    var HTMLCOptionValueElement: {
        prototype: HTMLCOptionValueElement;
        new (): HTMLCOptionValueElement;
    };
    interface HTMLCOtpInputElementEventMap {
        "changeValue": string;
        "completion": string;
    }
    /**
     * @group Form
     */
    interface HTMLCOtpInputElement extends Components.COtpInput, HTMLStencilElement {
        addEventListener<K extends keyof HTMLCOtpInputElementEventMap>(type: K, listener: (this: HTMLCOtpInputElement, ev: COtpInputCustomEvent<HTMLCOtpInputElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLCOtpInputElementEventMap>(type: K, listener: (this: HTMLCOtpInputElement, ev: COtpInputCustomEvent<HTMLCOtpInputElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLCOtpInputElement: {
        prototype: HTMLCOtpInputElement;
        new (): HTMLCOtpInputElement;
    };
    /**
     * @group Layout
     */
    interface HTMLCPageElement extends Components.CPage, HTMLStencilElement {
    }
    var HTMLCPageElement: {
        prototype: HTMLCPageElement;
        new (): HTMLCPageElement;
    };
    interface HTMLCPaginationElementEventMap {
        "changeValue": CPaginationOptions;
    }
    /**
     * @group Navigation
     */
    interface HTMLCPaginationElement extends Components.CPagination, HTMLStencilElement {
        addEventListener<K extends keyof HTMLCPaginationElementEventMap>(type: K, listener: (this: HTMLCPaginationElement, ev: CPaginationCustomEvent<HTMLCPaginationElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLCPaginationElementEventMap>(type: K, listener: (this: HTMLCPaginationElement, ev: CPaginationCustomEvent<HTMLCPaginationElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLCPaginationElement: {
        prototype: HTMLCPaginationElement;
        new (): HTMLCPaginationElement;
    };
    /**
     * @group Indicators
     */
    interface HTMLCProgressBarElement extends Components.CProgressBar, HTMLStencilElement {
    }
    var HTMLCProgressBarElement: {
        prototype: HTMLCProgressBarElement;
        new (): HTMLCProgressBarElement;
    };
    /**
     * @parent c-radio-group
     */
    interface HTMLCRadioElement extends Components.CRadio, HTMLStencilElement {
    }
    var HTMLCRadioElement: {
        prototype: HTMLCRadioElement;
        new (): HTMLCRadioElement;
    };
    interface HTMLCRadioGroupElementEventMap {
        "changeValue": any;
    }
    /**
     * @group Form
     */
    interface HTMLCRadioGroupElement extends Components.CRadioGroup, HTMLStencilElement {
        addEventListener<K extends keyof HTMLCRadioGroupElementEventMap>(type: K, listener: (this: HTMLCRadioGroupElement, ev: CRadioGroupCustomEvent<HTMLCRadioGroupElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLCRadioGroupElementEventMap>(type: K, listener: (this: HTMLCRadioGroupElement, ev: CRadioGroupCustomEvent<HTMLCRadioGroupElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLCRadioGroupElement: {
        prototype: HTMLCRadioGroupElement;
        new (): HTMLCRadioGroupElement;
    };
    /**
     * @parent None
     */
    interface HTMLCRippleElement extends Components.CRipple, HTMLStencilElement {
    }
    var HTMLCRippleElement: {
        prototype: HTMLCRippleElement;
        new (): HTMLCRippleElement;
    };
    /**
     * Generic flex row component
     * @group Layout
     */
    interface HTMLCRowElement extends Components.CRow, HTMLStencilElement {
    }
    var HTMLCRowElement: {
        prototype: HTMLCRowElement;
        new (): HTMLCRowElement;
    };
    interface HTMLCSelectElementEventMap {
        "changeValue": any;
    }
    /**
     * @group Form
     */
    interface HTMLCSelectElement extends Components.CSelect, HTMLStencilElement {
        addEventListener<K extends keyof HTMLCSelectElementEventMap>(type: K, listener: (this: HTMLCSelectElement, ev: CSelectCustomEvent<HTMLCSelectElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLCSelectElementEventMap>(type: K, listener: (this: HTMLCSelectElement, ev: CSelectCustomEvent<HTMLCSelectElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLCSelectElement: {
        prototype: HTMLCSelectElement;
        new (): HTMLCSelectElement;
    };
    /**
     * @group Navigation
     */
    interface HTMLCSideNavigationElement extends Components.CSideNavigation, HTMLStencilElement {
    }
    var HTMLCSideNavigationElement: {
        prototype: HTMLCSideNavigationElement;
        new (): HTMLCSideNavigationElement;
    };
    interface HTMLCSideNavigationItemElementEventMap {
        "itemChange": any;
    }
    /**
     * @parent c-side-navigation
     */
    interface HTMLCSideNavigationItemElement extends Components.CSideNavigationItem, HTMLStencilElement {
        addEventListener<K extends keyof HTMLCSideNavigationItemElementEventMap>(type: K, listener: (this: HTMLCSideNavigationItemElement, ev: CSideNavigationItemCustomEvent<HTMLCSideNavigationItemElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLCSideNavigationItemElementEventMap>(type: K, listener: (this: HTMLCSideNavigationItemElement, ev: CSideNavigationItemCustomEvent<HTMLCSideNavigationItemElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLCSideNavigationItemElement: {
        prototype: HTMLCSideNavigationItemElement;
        new (): HTMLCSideNavigationItemElement;
    };
    /**
     * @parent c-side-navigation
     */
    interface HTMLCSideNavigationTitleElement extends Components.CSideNavigationTitle, HTMLStencilElement {
    }
    var HTMLCSideNavigationTitleElement: {
        prototype: HTMLCSideNavigationTitleElement;
        new (): HTMLCSideNavigationTitleElement;
    };
    interface HTMLCSliderElementEventMap {
        "changeValue": any;
    }
    /**
     * @group Form
     */
    interface HTMLCSliderElement extends Components.CSlider, HTMLStencilElement {
        addEventListener<K extends keyof HTMLCSliderElementEventMap>(type: K, listener: (this: HTMLCSliderElement, ev: CSliderCustomEvent<HTMLCSliderElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLCSliderElementEventMap>(type: K, listener: (this: HTMLCSliderElement, ev: CSliderCustomEvent<HTMLCSliderElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLCSliderElement: {
        prototype: HTMLCSliderElement;
        new (): HTMLCSliderElement;
    };
    /**
     * Spacer component for flex containers
     * @group Layout
     */
    interface HTMLCSpacerElement extends Components.CSpacer, HTMLStencilElement {
    }
    var HTMLCSpacerElement: {
        prototype: HTMLCSpacerElement;
        new (): HTMLCSpacerElement;
    };
    /**
     * @group indicators
     */
    interface HTMLCSpinnerElement extends Components.CSpinner, HTMLStencilElement {
    }
    var HTMLCSpinnerElement: {
        prototype: HTMLCSpinnerElement;
        new (): HTMLCSpinnerElement;
    };
    /**
     * @group Indicators
     */
    interface HTMLCStatusElement extends Components.CStatus, HTMLStencilElement {
    }
    var HTMLCStatusElement: {
        prototype: HTMLCStatusElement;
        new (): HTMLCStatusElement;
    };
    /**
     * @group Indicators
     * @parent c-steps
     */
    interface HTMLCStepElement extends Components.CStep, HTMLStencilElement {
    }
    var HTMLCStepElement: {
        prototype: HTMLCStepElement;
        new (): HTMLCStepElement;
    };
    interface HTMLCStepsElementEventMap {
        "changeValue": number | string;
    }
    /**
     * @group Indicators
     */
    interface HTMLCStepsElement extends Components.CSteps, HTMLStencilElement {
        addEventListener<K extends keyof HTMLCStepsElementEventMap>(type: K, listener: (this: HTMLCStepsElement, ev: CStepsCustomEvent<HTMLCStepsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLCStepsElementEventMap>(type: K, listener: (this: HTMLCStepsElement, ev: CStepsCustomEvent<HTMLCStepsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLCStepsElement: {
        prototype: HTMLCStepsElement;
        new (): HTMLCStepsElement;
    };
    /**
     * @parent c-side-navigation
     */
    interface HTMLCSubNavigationItemElement extends Components.CSubNavigationItem, HTMLStencilElement {
    }
    var HTMLCSubNavigationItemElement: {
        prototype: HTMLCSubNavigationItemElement;
        new (): HTMLCSubNavigationItemElement;
    };
    interface HTMLCSwiperElementEventMap {
        "changeValue": number | string;
    }
    /**
     * @group Content Selectors
     */
    interface HTMLCSwiperElement extends Components.CSwiper, HTMLStencilElement {
        addEventListener<K extends keyof HTMLCSwiperElementEventMap>(type: K, listener: (this: HTMLCSwiperElement, ev: CSwiperCustomEvent<HTMLCSwiperElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLCSwiperElementEventMap>(type: K, listener: (this: HTMLCSwiperElement, ev: CSwiperCustomEvent<HTMLCSwiperElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLCSwiperElement: {
        prototype: HTMLCSwiperElement;
        new (): HTMLCSwiperElement;
    };
    interface HTMLCSwiperTabElementEventMap {
        "changeValue": number | string;
    }
    /**
     * @parent c-swiper
     */
    interface HTMLCSwiperTabElement extends Components.CSwiperTab, HTMLStencilElement {
        addEventListener<K extends keyof HTMLCSwiperTabElementEventMap>(type: K, listener: (this: HTMLCSwiperTabElement, ev: CSwiperTabCustomEvent<HTMLCSwiperTabElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLCSwiperTabElementEventMap>(type: K, listener: (this: HTMLCSwiperTabElement, ev: CSwiperTabCustomEvent<HTMLCSwiperTabElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLCSwiperTabElement: {
        prototype: HTMLCSwiperTabElement;
        new (): HTMLCSwiperTabElement;
    };
    interface HTMLCSwitchElementEventMap {
        "changeValue": any;
    }
    /**
     * @group Form
     */
    interface HTMLCSwitchElement extends Components.CSwitch, HTMLStencilElement {
        addEventListener<K extends keyof HTMLCSwitchElementEventMap>(type: K, listener: (this: HTMLCSwitchElement, ev: CSwitchCustomEvent<HTMLCSwitchElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLCSwitchElementEventMap>(type: K, listener: (this: HTMLCSwitchElement, ev: CSwitchCustomEvent<HTMLCSwitchElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLCSwitchElement: {
        prototype: HTMLCSwitchElement;
        new (): HTMLCSwitchElement;
    };
    interface HTMLCTabElementEventMap {
        "tabChange": {
    value: number | string;
    element: HTMLCTabElement;
  };
        "tabFocus": number | string;
    }
    /**
     * @group Tabs
     * @parent c-tabs
     */
    interface HTMLCTabElement extends Components.CTab, HTMLStencilElement {
        addEventListener<K extends keyof HTMLCTabElementEventMap>(type: K, listener: (this: HTMLCTabElement, ev: CTabCustomEvent<HTMLCTabElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLCTabElementEventMap>(type: K, listener: (this: HTMLCTabElement, ev: CTabCustomEvent<HTMLCTabElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLCTabElement: {
        prototype: HTMLCTabElement;
        new (): HTMLCTabElement;
    };
    interface HTMLCTabButtonsElementEventMap {
        "changeValue": number | string;
    }
    /**
     * @group Content Selectors
     */
    interface HTMLCTabButtonsElement extends Components.CTabButtons, HTMLStencilElement {
        addEventListener<K extends keyof HTMLCTabButtonsElementEventMap>(type: K, listener: (this: HTMLCTabButtonsElement, ev: CTabButtonsCustomEvent<HTMLCTabButtonsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLCTabButtonsElementEventMap>(type: K, listener: (this: HTMLCTabButtonsElement, ev: CTabButtonsCustomEvent<HTMLCTabButtonsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLCTabButtonsElement: {
        prototype: HTMLCTabButtonsElement;
        new (): HTMLCTabButtonsElement;
    };
    interface HTMLCTabItemElementEventMap {
        "contentChange": any;
    }
    /**
     * @parent c-tabs
     */
    interface HTMLCTabItemElement extends Components.CTabItem, HTMLStencilElement {
        addEventListener<K extends keyof HTMLCTabItemElementEventMap>(type: K, listener: (this: HTMLCTabItemElement, ev: CTabItemCustomEvent<HTMLCTabItemElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLCTabItemElementEventMap>(type: K, listener: (this: HTMLCTabItemElement, ev: CTabItemCustomEvent<HTMLCTabItemElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLCTabItemElement: {
        prototype: HTMLCTabItemElement;
        new (): HTMLCTabItemElement;
    };
    /**
     * @parent c-tabs
     */
    interface HTMLCTabItemsElement extends Components.CTabItems, HTMLStencilElement {
    }
    var HTMLCTabItemsElement: {
        prototype: HTMLCTabItemsElement;
        new (): HTMLCTabItemsElement;
    };
    /**
     * @group tables
     */
    interface HTMLCTableElement extends Components.CTable, HTMLStencilElement {
    }
    var HTMLCTableElement: {
        prototype: HTMLCTableElement;
        new (): HTMLCTableElement;
    };
    interface HTMLCTabsElementEventMap {
        "changeValue": any;
    }
    /**
     * @group Content Selectors
     */
    interface HTMLCTabsElement extends Components.CTabs, HTMLStencilElement {
        addEventListener<K extends keyof HTMLCTabsElementEventMap>(type: K, listener: (this: HTMLCTabsElement, ev: CTabsCustomEvent<HTMLCTabsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLCTabsElementEventMap>(type: K, listener: (this: HTMLCTabsElement, ev: CTabsCustomEvent<HTMLCTabsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLCTabsElement: {
        prototype: HTMLCTabsElement;
        new (): HTMLCTabsElement;
    };
    interface HTMLCTagElementEventMap {
        "close": any;
    }
    /**
     * @parent c-tags
     */
    interface HTMLCTagElement extends Components.CTag, HTMLStencilElement {
        addEventListener<K extends keyof HTMLCTagElementEventMap>(type: K, listener: (this: HTMLCTagElement, ev: CTagCustomEvent<HTMLCTagElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLCTagElementEventMap>(type: K, listener: (this: HTMLCTagElement, ev: CTagCustomEvent<HTMLCTagElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLCTagElement: {
        prototype: HTMLCTagElement;
        new (): HTMLCTagElement;
    };
    /**
     * @group buttons
     */
    interface HTMLCTagsElement extends Components.CTags, HTMLStencilElement {
    }
    var HTMLCTagsElement: {
        prototype: HTMLCTagsElement;
        new (): HTMLCTagsElement;
    };
    interface HTMLCTextFieldElementEventMap {
        "changeValue": any;
    }
    /**
     * @group Form
     */
    interface HTMLCTextFieldElement extends Components.CTextField, HTMLStencilElement {
        addEventListener<K extends keyof HTMLCTextFieldElementEventMap>(type: K, listener: (this: HTMLCTextFieldElement, ev: CTextFieldCustomEvent<HTMLCTextFieldElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLCTextFieldElementEventMap>(type: K, listener: (this: HTMLCTextFieldElement, ev: CTextFieldCustomEvent<HTMLCTextFieldElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLCTextFieldElement: {
        prototype: HTMLCTextFieldElement;
        new (): HTMLCTextFieldElement;
    };
    interface HTMLCToastElementEventMap {
        "close": CToastMessage;
    }
    /**
     * @parent none
     */
    interface HTMLCToastElement extends Components.CToast, HTMLStencilElement {
        addEventListener<K extends keyof HTMLCToastElementEventMap>(type: K, listener: (this: HTMLCToastElement, ev: CToastCustomEvent<HTMLCToastElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLCToastElementEventMap>(type: K, listener: (this: HTMLCToastElement, ev: CToastCustomEvent<HTMLCToastElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLCToastElement: {
        prototype: HTMLCToastElement;
        new (): HTMLCToastElement;
    };
    /**
     * @group Popups
     */
    interface HTMLCToastsElement extends Components.CToasts, HTMLStencilElement {
    }
    var HTMLCToastsElement: {
        prototype: HTMLCToastsElement;
        new (): HTMLCToastsElement;
    };
    /**
     * @group Navigation
     */
    interface HTMLCToolbarElement extends Components.CToolbar, HTMLStencilElement {
    }
    var HTMLCToolbarElement: {
        prototype: HTMLCToolbarElement;
        new (): HTMLCToolbarElement;
    };
    interface HTMLElementTagNameMap {
        "c-accordion": HTMLCAccordionElement;
        "c-accordion-item": HTMLCAccordionItemElement;
        "c-alert": HTMLCAlertElement;
        "c-autocomplete": HTMLCAutocompleteElement;
        "c-badge": HTMLCBadgeElement;
        "c-button": HTMLCButtonElement;
        "c-card": HTMLCCardElement;
        "c-card-actions": HTMLCCardActionsElement;
        "c-card-content": HTMLCCardContentElement;
        "c-card-title": HTMLCCardTitleElement;
        "c-checkbox": HTMLCCheckboxElement;
        "c-csc-logo": HTMLCCscLogoElement;
        "c-data-table": HTMLCDataTableElement;
        "c-dropdown": HTMLCDropdownElement;
        "c-icon": HTMLCIconElement;
        "c-icon-button": HTMLCIconButtonElement;
        "c-input": HTMLCInputElement;
        "c-link": HTMLCLinkElement;
        "c-list": HTMLCListElement;
        "c-list-item": HTMLCListItemElement;
        "c-list-item-title": HTMLCListItemTitleElement;
        "c-loader": HTMLCLoaderElement;
        "c-login-button": HTMLCLoginButtonElement;
        "c-login-buttons": HTMLCLoginButtonsElement;
        "c-login-card": HTMLCLoginCardElement;
        "c-login-card-actions": HTMLCLoginCardActionsElement;
        "c-login-card-content": HTMLCLoginCardContentElement;
        "c-login-card-title": HTMLCLoginCardTitleElement;
        "c-main": HTMLCMainElement;
        "c-menu": HTMLCMenuElement;
        "c-menu-items": HTMLCMenuItemsElement;
        "c-message": HTMLCMessageElement;
        "c-modal": HTMLCModalElement;
        "c-navigation-button": HTMLCNavigationButtonElement;
        "c-option": HTMLCOptionElement;
        "c-option-value": HTMLCOptionValueElement;
        "c-otp-input": HTMLCOtpInputElement;
        "c-page": HTMLCPageElement;
        "c-pagination": HTMLCPaginationElement;
        "c-progress-bar": HTMLCProgressBarElement;
        "c-radio": HTMLCRadioElement;
        "c-radio-group": HTMLCRadioGroupElement;
        "c-ripple": HTMLCRippleElement;
        "c-row": HTMLCRowElement;
        "c-select": HTMLCSelectElement;
        "c-side-navigation": HTMLCSideNavigationElement;
        "c-side-navigation-item": HTMLCSideNavigationItemElement;
        "c-side-navigation-title": HTMLCSideNavigationTitleElement;
        "c-slider": HTMLCSliderElement;
        "c-spacer": HTMLCSpacerElement;
        "c-spinner": HTMLCSpinnerElement;
        "c-status": HTMLCStatusElement;
        "c-step": HTMLCStepElement;
        "c-steps": HTMLCStepsElement;
        "c-sub-navigation-item": HTMLCSubNavigationItemElement;
        "c-swiper": HTMLCSwiperElement;
        "c-swiper-tab": HTMLCSwiperTabElement;
        "c-switch": HTMLCSwitchElement;
        "c-tab": HTMLCTabElement;
        "c-tab-buttons": HTMLCTabButtonsElement;
        "c-tab-item": HTMLCTabItemElement;
        "c-tab-items": HTMLCTabItemsElement;
        "c-table": HTMLCTableElement;
        "c-tabs": HTMLCTabsElement;
        "c-tag": HTMLCTagElement;
        "c-tags": HTMLCTagsElement;
        "c-text-field": HTMLCTextFieldElement;
        "c-toast": HTMLCToastElement;
        "c-toasts": HTMLCToastsElement;
        "c-toolbar": HTMLCToolbarElement;
    }
}
declare namespace LocalJSX {
    /**
     * @group Content Selectors
     */
    interface CAccordion {
        /**
          * Disallow collapsing all the items
         */
        "mandatory"?: boolean;
        /**
          * Allow expanding multiple items
         */
        "multiple"?: boolean;
        /**
          * Emit changes to the parent
         */
        "onChangeValue"?: (event: CAccordionCustomEvent<number | string>) => void;
        /**
          * Show an outline around expanded items
         */
        "outlined"?: boolean;
        /**
          * Value of the accordion
         */
        "value": number | string | (number | string)[];
    }
    /**
     * @parent c-accordion
     */
    interface CAccordionItem {
        /**
          * Marks the item as collapsable
          * @private
         */
        "collapsable"?: boolean;
        /**
          * Expansion status of the item
         */
        "expanded"?: boolean;
        /**
          * Heading of the accordion item
         */
        "heading"?: string;
        /**
          * Emit changes to the c-accordion
          * @private
         */
        "onItemChange"?: (event: CAccordionItemCustomEvent<any>) => void;
        /**
          * Show an outline around the expanded item
          * @private
         */
        "outlined"?: boolean;
        /**
          * Value of the accordion item
         */
        "value"?: number | string;
    }
    /**
     * @group Indicators
     */
    interface CAlert {
        /**
          * Type of the alert
         */
        "type"?: CAlertType;
    }
    /**
     * @group Form
     */
    interface CAutocomplete {
        /**
          * Disable the input
         */
        "disabled"?: boolean;
        /**
          * Hide the hint and error messages
         */
        "hideDetails"?: boolean;
        /**
          * Hint text for the input
         */
        "hint"?: string;
        /**
          * Id of the element
         */
        "hostId"?: string;
        /**
          * Dropdown items
         */
        "items"?: CAutocompleteItem[];
        /**
          * Items per page before adding scroll
         */
        "itemsPerPage"?: number;
        /**
          * Element label
         */
        "label"?: string;
        /**
          * Show loading state
         */
        "loading"?: boolean;
        /**
          * Minimum query length
         */
        "minimumQueryLength"?: number;
        /**
          * Minimum query length message
         */
        "minimumQueryLengthMessage"?: string;
        /**
          * Input field name
         */
        "name"?: string;
        /**
          * No matching items message
         */
        "noMatchingItemsMessage"?: string;
        /**
          * Triggered when text is typed
         */
        "onChangeQuery"?: (event: CAutocompleteCustomEvent<any>) => void;
        /**
          * Triggered when option is selected
         */
        "onChangeValue"?: (event: CAutocompleteCustomEvent<any>) => void;
        /**
          * Placeholder text
         */
        "placeholder"?: string;
        /**
          * Search string
         */
        "query"?: string;
        /**
          * Show required validation
         */
        "required"?: boolean;
        /**
          * Return object instead of value
         */
        "returnObject"?: boolean;
        /**
          * Shadow variant
         */
        "shadow"?: boolean;
        /**
          * Set the validÃ­ty of the input
         */
        "valid"?: boolean;
        /**
          * Manual validation
         */
        "validate"?: boolean;
        /**
          * Validate the input on blur
         */
        "validateOnBlur"?: boolean;
        /**
          * Custom validation message
         */
        "validation"?: string;
        /**
          * Selected item
         */
        "value"?: string | number | CAutocompleteItem;
    }
    /**
     * @parent none
     */
    interface CBadge {
    }
    /**
     * @group Buttons
     */
    interface CButton {
        /**
          * Danger variant style
         */
        "danger"?: boolean;
        /**
          * Disable the button
         */
        "disabled"?: boolean;
        /**
          * Fit width to containing element
         */
        "fit"?: boolean;
        /**
          * Light button background
         */
        "ghost"?: boolean;
        /**
          * True when used as a tab button
          * @private
         */
        "grouped"?: boolean;
        /**
          * Id of the button
         */
        "hostId"?: string;
        /**
          * Hyperlink url
         */
        "href"?: string;
        /**
          * Inverted button style for dark backgrounds
         */
        "inverted"?: boolean;
        /**
          * Display loader on the button
         */
        "loading"?: boolean;
        /**
          * Remove the default border radius
         */
        "noRadius"?: boolean;
        /**
          * Emit changes to the parent
          * @private
         */
        "onTabChange"?: (event: CButtonCustomEvent<{
    value: number | string;
    element: HTMLCButtonElement;
  }>) => void;
        /**
          * Emit focus to the parent
          * @private
         */
        "onTabFocus"?: (event: CButtonCustomEvent<number | string>) => void;
        /**
          * Outlined button style
         */
        "outlined"?: boolean;
        /**
          * Size of the button
         */
        "size"?: 'default' | 'small' | 'large';
        /**
          * Used a s atab button
          * @private
         */
        "tabs"?: boolean;
        /**
          * Hyperlink target
         */
        "target"?: string;
        /**
          * Transparent button background
         */
        "text"?: boolean;
        /**
          * Button type
         */
        "type"?: 'button' | 'submit';
        /**
          * Value for the button - for use in the c-tab-buttons
         */
        "value"?: number | string;
    }
    /**
     * @group Cards
     */
    interface CCard {
        /**
          * Enable the fullscreen toggle button
         */
        "fullscreen"?: boolean;
    }
    /**
     * @parent c-card
     */
    interface CCardActions {
        /**
          * Align the actions
         */
        "align"?: 'start' | 'center' | 'end';
        /**
          * Justify the actions
         */
        "justify"?: | 'start'
    | 'center'
    | 'end'
    | 'space-between'
    | 'stretch'
    | 'space-around';
    }
    /**
     * @parent c-card
     */
    interface CCardContent {
    }
    /**
     * @parent c-card
     */
    interface CCardTitle {
    }
    /**
     * @group Form
     */
    interface CCheckbox {
        /**
          * If `true`, the checkbox is selected.
         */
        "checked"?: boolean;
        /**
          * Disable the checkbox
         */
        "disabled"?: boolean;
        /**
          * The value when the checkbox is unchecked
         */
        "falseValue"?: boolean | string;
        /**
          * Hide the hint and error messages
         */
        "hideDetails"?: boolean;
        /**
          * Hint text for the input
         */
        "hint"?: string;
        /**
          * Id of the element
         */
        "hostId"?: string;
        /**
          * Name of the input - Only used when the checkbox participates in a native `<form>`
         */
        "hostName"?: string;
        /**
          * Indeterminate state
         */
        "indeterminate"?: boolean;
        /**
          * Element label
         */
        "label"?: string;
        /**
          * Triggered when element is checked or unchecked
         */
        "onChangeValue"?: (event: CCheckboxCustomEvent<any>) => void;
        /**
          * Set as required
         */
        "required"?: boolean;
        /**
          * The value when the checkbox is checked
         */
        "trueValue"?: boolean | string;
        /**
          * Set the validity of the input
         */
        "valid"?: boolean;
        /**
          * Custom validation message
         */
        "validation"?: string;
        /**
          * The input value - Only used when the checkbox participates in a native `<form>`
         */
        "value"?: string | boolean;
    }
    /**
     * @parent c-toolbar
     */
    interface CCscLogo {
        /**
          * Logo width in pixels
         */
        "width"?: number;
    }
    /**
     * @group Tables
     */
    interface CDataTable {
        /**
          * Data of the table
         */
        "data"?: CDataTableData[];
        /**
          * Externally sorted and paginated data
         */
        "externalData"?: boolean;
        /**
          * Items per page options
         */
        "footerOptions"?: CDataTableFooterOptions;
        /**
          * Headers of the table
         */
        "headers"?: CDataTableHeader[];
        /**
          * Hide the footer
         */
        "hideFooter"?: boolean;
        /**
          * Use horizontal scrolling
         */
        "horizontalScrolling"?: boolean;
        /**
          * Show a loader on top of the table
         */
        "loading"?: boolean;
        /**
          * Text shown when there is no data and the table is loading
         */
        "loadingText"?: string;
        /**
          * Text shown when there are no data available
         */
        "noDataText"?: string;
        /**
          * Triggered on row expansion
         */
        "onExpand"?: (event: CDataTableCustomEvent<any>) => void;
        /**
          * Triggered on pagination
         */
        "onPaginate"?: (event: CDataTableCustomEvent<CPaginationOptions>) => void;
        /**
          * Triggered on selection
         */
        "onSelection"?: (event: CDataTableCustomEvent<any>) => void;
        /**
          * Triggered on sort
         */
        "onSort"?: (event: CDataTableCustomEvent<any>) => void;
        /**
          * Pagination options
         */
        "pagination"?: CPaginationOptions;
        /**
          * Make rows selectable
         */
        "selectable"?: boolean;
        /**
          * Property used in selections
         */
        "selectionProperty"?: string;
        /**
          * Allow only a single row expanded at a time
         */
        "singleExpansion"?: boolean;
        /**
          * Select only a single row at a time
         */
        "singleSelection"?: boolean;
        /**
          * Sort data by
         */
        "sortBy"?: any;
        /**
          * Sorting direction
         */
        "sortDirection"?: 'asc' | 'desc' | null;
        /**
          * Use sticky header
         */
        "stickyHeader"?: boolean;
    }
    interface CDropdown {
        /**
          * Id of the element
         */
        "hostId"?: string;
        /**
          * Current index value
         */
        "index"?: number;
        /**
          * Type of items
         */
        "itemType"?: 'option' | 'item';
        /**
          * Dropdown options
         */
        "items"?: | NodeListOf<HTMLCOptionElement>
    | CAutocompleteItem[]
    | CSelectItem[];
        /**
          * Items per page before adding scroll
         */
        "itemsPerPage"?: number;
        /**
          * Triggered when dropdown opens or closes
         */
        "onDropdownStateChange"?: (event: CDropdownCustomEvent<boolean>) => void;
        /**
          * Triggered when option is selected
         */
        "onSelectOption"?: (event: CDropdownCustomEvent<any>) => void;
        /**
          * Dropdown parent
         */
        "parent"?: HTMLCSelectElement | HTMLCAutocompleteElement;
        /**
          * Type of the parent element
         */
        "type"?: 'select' | 'autocomplete';
    }
    /**
     * @group Other
     */
    interface CIcon {
        /**
          * Fill color
         */
        "color"?: string;
        /**
          * Svg path d attribute value
         */
        "path"?: string;
        /**
          * Icon size in pixels
         */
        "size"?: number;
    }
    /**
     * @group Buttons
     */
    interface CIconButton {
        /**
          * Show a badge on top of the icon
         */
        "badge"?: string;
        /**
          * Danger variant of the button
         */
        "danger"?: boolean;
        /**
          * Disable the button
         */
        "disabled"?: boolean;
        /**
          * Ghost variant of the button
         */
        "ghost"?: boolean;
        /**
          * Inverted color for dark backgrounds
         */
        "inverted"?: boolean;
        /**
          * Loading variant of the button
         */
        "loading"?: boolean;
        /**
          * Outlined variant of the button
         */
        "outlined"?: boolean;
        /**
          * Path for the svg icon
         */
        "path"?: string;
        /**
          * Size of the button
         */
        "size"?: 'default' | 'x-small' | 'small';
        /**
          * Text variant of the button
         */
        "text"?: boolean;
    }
    /**
     * @parent None
     */
    interface CInput {
        /**
          * Active state
         */
        "active"?: boolean;
        /**
          * Auto focus the input
         */
        "autofocus"?: boolean;
        /**
          * Disable the input
         */
        "disabled"?: boolean;
        /**
          * Render a hidden input outside the shadow dom
         */
        "form"?: boolean;
        /**
          * Hide the hint and error messages
         */
        "hideDetails"?: boolean;
        /**
          * Hint text for the input
         */
        "hint"?: string;
        /**
          * Id of the input
         */
        "hostId"?: string;
        /**
          * Id of the input element
         */
        "inputId"?: string;
        /**
          * Items for the dropdown
         */
        "items"?: CSelectItem[];
        /**
          * Items per page before adding scroll
         */
        "itemsPerPage"?: number;
        /**
          * Label of the input
         */
        "label"?: string;
        /**
          * Maximum value on a numeric input
         */
        "max"?: number;
        /**
          * Minimum value on a numeric input
         */
        "min"?: number;
        /**
          * Name of the input
         */
        "name"?: string;
        /**
          * Emit changes to the parent
         */
        "onChangeValue"?: (event: CInputCustomEvent<any>) => void;
        /**
          * Emit close to the parent
          * @private
         */
        "onDropdownClose"?: (event: CInputCustomEvent<any>) => void;
        /**
          * Emit click to the parent
          * @private
         */
        "onItemClick"?: (event: CInputCustomEvent<any>) => void;
        /**
          * Placeholder of the input
         */
        "placeholder"?: string;
        /**
          * Mark as readonly
         */
        "readonly"?: boolean;
        /**
          * Set the input as required
         */
        "required"?: boolean;
        /**
          * Rows on the input
         */
        "rows"?: number;
        /**
          * Shadow variant of the input
         */
        "shadow"?: boolean;
        /**
          * Step size on a numeric input
         */
        "step"?: number;
        /**
          * Type of the input
         */
        "type"?: string;
        /**
          * Set the validÃ­ty of the input
         */
        "valid"?: boolean;
        /**
          * Manual validation
         */
        "validate"?: boolean;
        /**
          * Validate the input on blur
         */
        "validateOnBlur"?: boolean;
        /**
          * Custom validation message
         */
        "validation"?: string;
        /**
          * Value of the input
         */
        "value"?: string | number | boolean | CSelectItem | CAutocompleteItem;
        /**
          * Variant
         */
        "variant"?: 'text' | 'select';
    }
    /**
     * Basic hyperlink component
     * @group Buttons
     */
    interface CLink {
        /**
          * Url of link
         */
        "href"?: string;
        /**
          * regular target attribute of a hyperlink
         */
        "target"?: string;
        /**
          * Display line under the link
         */
        "underline"?: boolean;
        /**
          * Customisable font weight
         */
        "weight"?: string;
    }
    /**
     * @group Other
     */
    interface CList {
        /**
          * Disable the list
         */
        "disabled"?: boolean;
    }
    interface CListItem {
        /**
          * Set the item active
         */
        "active"?: boolean;
        /**
          * Disable the item
         */
        "disabled"?: boolean;
        /**
          * Disabled by the parent list
          * @private
         */
        "disabledByParent"?: boolean;
        /**
          * Display background color on hover
         */
        "hoverable"?: boolean;
        /**
          * Hyperlink url
         */
        "href"?: string;
        /**
          * Add ripple effect to the item
         */
        "ripple"?: boolean;
        /**
          * Hyperlink target
         */
        "target"?: string;
    }
    interface CListItemTitle {
        /**
          * Set the title active
         */
        "active"?: boolean;
    }
    /**
     * A loader component that fills the nearest containing element that has css-property position set to 'relative'
     * @group Indicators
     */
    interface CLoader {
        /**
          * Delay in seconds of showing the contents in the slot of the loader
         */
        "contentdelay"?: number;
        /**
          * Hide the loader
         */
        "hide"?: boolean;
        /**
          * Size of the loader
         */
        "size"?: number;
        /**
          * Width of the loader
         */
        "width"?: number;
    }
    /**
     * @parent c-login-buttons
     */
    interface CLoginButton {
        /**
          * Alt description for logo
         */
        "alt"?: string;
        /**
          * Login provider link. Do not set if using a javascript click handler
         */
        "href"?: string;
        /**
          * Login provider logo url
         */
        "src": string;
    }
    /**
     * @group buttons
     */
    interface CLoginButtons {
    }
    /**
     * @group Cards
     */
    interface CLoginCard {
        /**
          * Background position (css background-position)
         */
        "backgroundPosition"?: string;
        /**
          * Mobile breakpoint in pixels
         */
        "mobileBreakpoint"?: number;
        /**
          * Add colored overlay to the background image
         */
        "overlay"?: boolean;
        /**
          * Add colored overlay to the background image
         */
        "overlayBlendMode"?: CLoginCardBlendMode;
        /**
          * Background image
         */
        "src"?: string;
    }
    /**
     * @parent c-login-card
     */
    interface CLoginCardActions {
        /**
          * Align the actions
         */
        "align"?: 'start' | 'center' | 'end';
        /**
          * Justify the actions
         */
        "justify"?: | 'start'
    | 'center'
    | 'end'
    | 'space-between'
    | 'stretch'
    | 'space-around';
    }
    /**
     * @parent c-login-card
     */
    interface CLoginCardContent {
    }
    /**
     * @parent c-login-card
     */
    interface CLoginCardTitle {
    }
    /**
     * Wrapper component for the whole page
     * @group Layout
     */
    interface CMain {
        /**
          * Disable the default dashboard layout
         */
        "disableLayout"?: boolean;
    }
    /**
     * @group Navigation
     */
    interface CMenu {
        /**
          * Menu content css class
         */
        "contentClass"?: string;
        /**
          * No chevron and background, E.g. when a button is the activator
         */
        "custom"?: boolean;
        /**
          * No hover background
         */
        "flat"?: boolean;
        /**
          * Menu items
         */
        "items"?: CMenuOption[];
        /**
          * Items per page before adding scroll
         */
        "itemsPerPage"?: number;
        /**
          * Small variant
         */
        "small"?: boolean;
    }
    /**
     * @parent c-menu
     */
    interface CMenuItems {
        /**
          * Menu is opened and positioned
          * @private
         */
        "active"?: boolean;
        /**
          * is active
          * @private
         */
        "index"?: number | null;
        /**
          * Menu items
          * @private
         */
        "items"?: CMenuOption[];
        /**
          * Items per page before adding scroll
          * @private
         */
        "itemsPerPage"?: number;
        /**
          * Triggered when the menu is closed
          * @private
         */
        "onClose"?: (event: CMenuItemsCustomEvent<any>) => void;
        /**
          * Triggered when the menu is opened
          * @private
         */
        "onOpen"?: (event: CMenuItemsCustomEvent<{
    height: number;
    width: number;
    isInView: {
      x: boolean;
      y: boolean;
    };
  }>) => void;
        /**
          * Menu parent
          * @private
         */
        "parent"?: HTMLCMenuElement;
        /**
          * Type of parent
          * @private
         */
        "parentType"?: string;
        /**
          * Small variant
          * @private
         */
        "small"?: boolean;
        /**
          * Initial top position
          * @private
         */
        "top"?: number;
    }
    /**
     * @parent None
     */
    interface CMessage {
        /**
          * Hint text for the input
         */
        "hint"?: string;
        /**
          * Id of the related input element
         */
        "inputId"?: string;
        /**
          * Parent validÃ­ty
         */
        "valid"?: boolean;
        /**
          * Custom validation message
         */
        "validation"?: string;
    }
    /**
     * @group Popups
     */
    interface CModal {
        /**
          * Disable backdrop blur effect
         */
        "disableBackdropBlur"?: boolean;
        /**
          * Dismissed when touching/clicking outside the content
         */
        "dismissable"?: boolean;
        /**
          * Triggered when value is changed
         */
        "onChangeValue"?: (event: CModalCustomEvent<boolean>) => void;
        /**
          * Is the modal visible
         */
        "value"?: boolean;
        /**
          * Width of the dialog. Numeric value is considered as pixel value (400 -> 400px)
         */
        "width"?: string | number;
        /**
          * Z-index of the modal
         */
        "zIndex"?: number;
    }
    /**
     * @parent c-toolbar
     */
    interface CNavigationButton {
    }
    /**
     * @parent c-select
     */
    interface COption {
        /**
          * Set option as disabled
         */
        "disabled"?: boolean;
        /**
          * Option name
         */
        "name"?: string;
        /**
          * Set option as selected
         */
        "selected"?: boolean;
        /**
          * Option value
         */
        "value"?: string | number;
    }
    interface COptionValue {
    }
    /**
     * @group Form
     */
    interface COtpInput {
        /**
          * Id of the element
         */
        "elementId": string;
        /**
          * Hide the hint and error messages
         */
        "hideDetails"?: boolean;
        /**
          * Hint text for the input
         */
        "hint"?: string;
        /**
          * Length of the OTP code
         */
        "length"?: number;
        /**
          * Run on input - returns the current value
         */
        "onChangeValue"?: (event: COtpInputCustomEvent<string>) => void;
        /**
          * Run on completion - returns the current value
         */
        "onCompletion"?: (event: COtpInputCustomEvent<string>) => void;
        /**
          * Set the validÃ­ty of the input
         */
        "valid"?: boolean;
        /**
          * Custom validation message
         */
        "validation"?: string;
        /**
          * Value of the input
         */
        "value"?: string;
    }
    /**
     * @group Layout
     */
    interface CPage {
        /**
          * Display scroll indicator
         */
        "scrollIndicator"?: boolean;
    }
    /**
     * @group Navigation
     */
    interface CPagination {
        /**
          * Hide details (per page dropdown and the 'x - y of n pages' text)
         */
        "hideDetails"?: boolean;
        /**
          * Hide range indicator
         */
        "hideRange"?: boolean;
        /**
          * Triggered when values are changed
         */
        "onChangeValue"?: (event: CPaginationCustomEvent<CPaginationOptions>) => void;
        /**
          * Hide page number buttons
         */
        "simple"?: boolean;
        /**
          * Hide details (per page dropdown and the 'x - y of n pages' text)
         */
        "size"?: 'default' | 'small';
        /**
          * Object containing values that are needed for pagination.  Note! startFrom and endTo are assigned automatically to the object based on other values
         */
        "value"?: CPaginationOptions;
    }
    /**
     * @group Indicators
     */
    interface CProgressBar {
        /**
          * Hide the percentage display
         */
        "hideDetails"?: boolean;
        /**
          * Indeterminate state of the progress bar
         */
        "indeterminate"?: boolean;
        /**
          * Optional details message next to percentage display
         */
        "label"?: string;
        /**
          * Place details next to progress bar
         */
        "singleLine"?: boolean;
        /**
          * Progress bar value in percentage (0 to 100)
         */
        "value"?: number;
    }
    /**
     * @parent c-radio-group
     */
    interface CRadio {
        /**
          * Set option as checked
         */
        "checked"?: boolean;
        /**
          * Disable the radio button
         */
        "disabled"?: boolean;
        /**
          * Radio button value
         */
        "value"?: string;
    }
    /**
     * @group Form
     */
    interface CRadioGroup {
        /**
          * Color of the radio group
         */
        "color"?: string;
        /**
          * Disable the radio group
         */
        "disabled"?: boolean;
        /**
          * Hide the hint and error messages
         */
        "hideDetails"?: boolean;
        /**
          * Hint text for the input
         */
        "hint"?: string;
        /**
          * Id of the element
         */
        "hostId"?: string;
        /**
          * Display radio buttons inline
         */
        "inline"?: boolean;
        /**
          * Radio group items
         */
        "items"?: CRadioGroupItem[];
        /**
          * Label of the radio group
         */
        "label"?: string;
        /**
          * Emit value change to the parent
         */
        "onChangeValue"?: (event: CRadioGroupCustomEvent<any>) => void;
        /**
          * Set as required
         */
        "required"?: boolean;
        /**
          * Return the whole item object
         */
        "returnObject"?: boolean;
        /**
          * Set the validity of the input
         */
        "valid"?: boolean;
        /**
          * Custom validation message
         */
        "validation"?: string;
        /**
          * Value of the radio group
         */
        "value"?: string | number | CRadioGroupItem;
    }
    /**
     * @parent None
     */
    interface CRipple {
    }
    /**
     * Generic flex row component
     * @group Layout
     */
    interface CRow {
        /**
          * Align items vertically
         */
        "align"?: CRowAlign;
        /**
          * Gap between items in px
         */
        "gap"?: number;
        /**
          * Justify content horizontally
         */
        "justify"?: CRowJustify;
        /**
          * Disable flex wrap
         */
        "nowrap"?: boolean;
    }
    /**
     * @group Form
     */
    interface CSelect {
        /**
          * Make the selected value clearable
         */
        "clearable"?: boolean;
        /**
          * Disable the input
         */
        "disabled"?: boolean;
        /**
          * Hide the hint and error messages
         */
        "hideDetails"?: boolean;
        /**
          * Hint text for the input
         */
        "hint"?: string;
        /**
          * Id of the element
         */
        "hostId"?: string;
        /**
          * Dropdown items
         */
        "items"?: CSelectItem[];
        /**
          * Items per page before adding scroll
         */
        "itemsPerPage"?: number;
        /**
          * Element label
         */
        "label"?: string;
        /**
          * Show loading state
         */
        "loading"?: boolean;
        /**
          * Input field name
         */
        "name"?: string;
        /**
          * Triggered when option is selected
         */
        "onChangeValue"?: (event: CSelectCustomEvent<any>) => void;
        /**
          * display the option as selection (works only when c-option elements are used)
         */
        "optionAsSelection"?: false;
        /**
          * Placeholder text
         */
        "placeholder"?: string;
        /**
          * Show required validation
         */
        "required"?: boolean;
        /**
          * Return object instead of value
         */
        "returnObject"?: boolean;
        /**
          * Shadow variant
         */
        "shadow"?: boolean;
        /**
          * Set the validÃ­ty of the input
         */
        "valid"?: boolean;
        /**
          * Manual validation
         */
        "validate"?: boolean;
        /**
          * Validate the input on blur
         */
        "validateOnBlur"?: boolean;
        /**
          * Custom validation message
         */
        "validation"?: string;
        /**
          * Selected item
         */
        "value"?: string | number | CSelectItem;
    }
    /**
     * @group Navigation
     */
    interface CSideNavigation {
        /**
          * Mobile version menu visibility
         */
        "menuVisible"?: boolean;
        /**
          * Mobile version
         */
        "mobile"?: boolean;
    }
    /**
     * @parent c-side-navigation
     */
    interface CSideNavigationItem {
        /**
          * Indicate active state
         */
        "active"?: boolean;
        /**
          * Hyperlink url
         */
        "href"?: string;
        /**
          * Loading state
         */
        "loading"?: boolean;
        /**
          * Emit changes to the c-accordion
          * @private
         */
        "onItemChange"?: (event: CSideNavigationItemCustomEvent<any>) => void;
        /**
          * Hyperlink target
         */
        "target"?: string;
    }
    /**
     * @parent c-side-navigation
     */
    interface CSideNavigationTitle {
    }
    /**
     * @group Form
     */
    interface CSlider {
        /**
          * Aria label
         */
        "ariaLabel"?: string;
        /**
          * Disable tooltip
         */
        "disableTooltip"?: boolean;
        /**
          * Disable the slider
         */
        "disabled"?: boolean;
        /**
          * Id of the element
         */
        "hostId"?: string;
        /**
          * Id of the element
         */
        "hostName"?: string;
        /**
          * Label of the slider
         */
        "label"?: string;
        /**
          * Show tick labels
         */
        "labels"?: boolean;
        /**
          * Max value
         */
        "max"?: string;
        /**
          * Min value
         */
        "min"?: string;
        /**
          * Emit value changes to parent
         */
        "onChangeValue"?: (event: CSliderCustomEvent<any>) => void;
        /**
          * Segment count
         */
        "segments"?: string;
        /**
          * Step
         */
        "step"?: string;
        /**
          * Thow ticks
         */
        "ticks"?: boolean;
        /**
          * Unit
         */
        "unit"?: string;
        /**
          * Value
         */
        "value"?: string | number;
    }
    /**
     * Spacer component for flex containers
     * @group Layout
     */
    interface CSpacer {
    }
    /**
     * @group indicators
     */
    interface CSpinner {
        /**
          * Color of the spinner
         */
        "color"?: string;
        /**
          * Size of the spinner
         */
        "size"?: number;
        /**
          * Width of the spinner
         */
        "width"?: number;
    }
    /**
     * @group Indicators
     */
    interface CStatus {
        /**
          * Status type
         */
        "type"?: 'info' | 'warning' | 'error' | 'success';
    }
    /**
     * @group Indicators
     * @parent c-steps
     */
    interface CStep {
        /**
          * Mark step as complete
          * @private
         */
        "complete"?: boolean;
        /**
          * Mark step as current
          * @private
         */
        "current"?: boolean;
    }
    /**
     * @group Indicators
     */
    interface CSteps {
        /**
          * Emit changes to the parent
         */
        "onChangeValue"?: (event: CStepsCustomEvent<number | string>) => void;
        /**
          * Value of the accordion (current step number)
         */
        "value": number | string;
    }
    /**
     * @parent c-side-navigation
     */
    interface CSubNavigationItem {
        /**
          * Active state
         */
        "active"?: boolean;
        /**
          * Element is visible and focusable
         */
        "focusable"?: boolean;
        /**
          * Link url
         */
        "href"?: string;
        /**
          * Loading state
         */
        "loading"?: boolean;
        /**
          * Link target
         */
        "target"?: string;
    }
    /**
     * @group Content Selectors
     */
    interface CSwiper {
        /**
          * Id of the swiper element
         */
        "elementId": string;
        /**
          * Emit value change to the parent
         */
        "onChangeValue"?: (event: CSwiperCustomEvent<number | string>) => void;
        /**
          * Value of the swiper
         */
        "value"?: number | string;
    }
    /**
     * @parent c-swiper
     */
    interface CSwiperTab {
        /**
          * Mark as active
         */
        "active"?: boolean;
        /**
          * Disable button
         */
        "disabled"?: boolean;
        /**
          * Id of the button
         */
        "hostId"?: string;
        /**
          * Label of the button
         */
        "label"?: string;
        /**
          * Emit value change to the parent
          * @private
         */
        "onChangeValue"?: (event: CSwiperTabCustomEvent<number | string>) => void;
        /**
          * Position in the set
          * @private
         */
        "position"?: number;
        /**
          * Size of the set
          * @private
         */
        "setsize"?: number;
        /**
          * Value of the button
         */
        "value"?: number | string;
    }
    /**
     * @group Form
     */
    interface CSwitch {
        /**
          * If `true`, the checkbox is selected.
         */
        "checked"?: boolean;
        /**
          * The value when the checkbox is unchecked
         */
        "falseValue"?: boolean | string;
        /**
          * Disable the switch
         */
        "hostDisabled"?: boolean;
        /**
          * Id for the element
         */
        "hostId"?: string;
        /**
          * Emit inner value change to parent
         */
        "onChangeValue"?: (event: CSwitchCustomEvent<any>) => void;
        /**
          * Set as required
         */
        "required"?: boolean;
        /**
          * The value when the checkbox is checked
         */
        "trueValue"?: boolean | string;
        /**
          * The input value - Only used when the checkbox participates in a native `<form>`
         */
        "value"?: string | boolean;
    }
    /**
     * @group Tabs
     * @parent c-tabs
     */
    interface CTab {
        /**
          * Mark tab as active
         */
        "active"?: boolean;
        /**
          * Mark tab as disabled
         */
        "disabled"?: boolean;
        /**
          * Id of the tab
         */
        "hostId"?: string;
        /**
          * Emit changes to the parent
          * @private
         */
        "onTabChange"?: (event: CTabCustomEvent<{
    value: number | string;
    element: HTMLCTabElement;
  }>) => void;
        /**
          * Emit focus to the parent
          * @private
         */
        "onTabFocus"?: (event: CTabCustomEvent<number | string>) => void;
        /**
          * Position in the set
          * @private
         */
        "position"?: number;
        /**
          * Size of the set
          * @private
         */
        "setsize"?: number;
        /**
          * Value for the tab - for use in c-tabs
         */
        "value"?: number | string;
    }
    /**
     * @group Content Selectors
     */
    interface CTabButtons {
        /**
          * Disable tab buttons
         */
        "hostDisabled"?: boolean;
        /**
          * Always require a selection
         */
        "mandatory"?: boolean;
        /**
          * Emit changes to the parent
         */
        "onChangeValue"?: (event: CTabButtonsCustomEvent<number | string>) => void;
        /**
          * Size of the buttons
         */
        "size"?: 'default' | 'small';
        /**
          * Used as controller for c-tabs
          * @private
         */
        "tabs"?: boolean;
        /**
          * Value of tab buttons
         */
        "value"?: number | string;
    }
    /**
     * @parent c-tabs
     */
    interface CTabItem {
        /**
          * Active
          * @private
         */
        "active"?: boolean;
        /**
          * Emit changes to the parent
         */
        "onContentChange"?: (event: CTabItemCustomEvent<any>) => void;
        /**
          * Tab value
         */
        "value": number | string;
    }
    /**
     * @parent c-tabs
     */
    interface CTabItems {
        /**
          * Disable animation
          * @private
         */
        "disableAnimation"?: boolean;
        /**
          * Currently active tab
         */
        "value": number | string;
    }
    /**
     * @group tables
     */
    interface CTable {
        /**
          * Mobile breakpoint in pixels
         */
        "mobileBreakpoint"?: number;
        /**
          * Should the table be responsive
         */
        "responsive"?: boolean;
    }
    /**
     * @group Content Selectors
     */
    interface CTabs {
        /**
          * Disable the bottom border
         */
        "borderless"?: boolean;
        /**
          * Disable animation
         */
        "disableAnimation"?: boolean;
        /**
          * Justification of the children
         */
        "justify"?: CTabsJustify;
        /**
          * Mobile breakpoint in pixels - affects the content stacking with the vertical tabs
         */
        "mobileBreakpoint"?: number;
        /**
          * Emit changes to the parent
         */
        "onChangeValue"?: (event: CTabsCustomEvent<any>) => void;
        /**
          * Currently active tab
         */
        "value": number | string;
        /**
          * Vertical tabs
         */
        "vertical"?: boolean;
    }
    /**
     * @parent c-tags
     */
    interface CTag {
        /**
          * Mark tag as active
         */
        "active"?: boolean;
        /**
          * Display an optional badge at the start of the tag
         */
        "badge"?: string | number;
        /**
          * Stretch to fill the container row
         */
        "block"?: boolean;
        /**
          * Mark tag as closeable
         */
        "closeable"?: boolean;
        /**
          * Stretch to fill the container
         */
        "fit"?: boolean;
        /**
          * Remove the hover effect
         */
        "flat"?: boolean;
        /**
          * Emit close event on close icon click
         */
        "onClose"?: (event: CTagCustomEvent<any>) => void;
        /**
          * Size of the tag
         */
        "size"?: 'default' | 'small';
    }
    /**
     * @group buttons
     */
    interface CTags {
        /**
          * Size of the tags
         */
        "size"?: 'default' | 'small';
    }
    /**
     * @group Form
     */
    interface CTextField {
        /**
          * HTML input autocapitalize
         */
        "autocapitalize"?: string;
        /**
          * HTML input autocomplete
         */
        "autocomplete"?: string;
        /**
          * HTML input autocorrect
         */
        "autocorrect"?: string;
        /**
          * Auto focus the input
         */
        "autofocus"?: boolean;
        /**
          * Disable the input
         */
        "disabled"?: boolean;
        /**
          * Hide the hint and error messages
         */
        "hideDetails"?: boolean;
        /**
          * Hint text for the input
         */
        "hint"?: string;
        /**
          * Id of the input
         */
        "hostId"?: string;
        /**
          * Label of the input
         */
        "label"?: string;
        /**
          * Maximum value on a numeric input
         */
        "max"?: number;
        /**
          * Minimum value on a numeric input
         */
        "min"?: number;
        /**
          * Name of the input
         */
        "name"?: string;
        /**
          * Emit changes to the parent
         */
        "onChangeValue"?: (event: CTextFieldCustomEvent<any>) => void;
        /**
          * Placeholder of the input
         */
        "placeholder"?: string;
        /**
          * Mark as readonly
         */
        "readonly"?: boolean;
        /**
          * Set the input as required
         */
        "required"?: boolean;
        /**
          * Rows on the input
         */
        "rows"?: number;
        /**
          * Shadow variant of the input
         */
        "shadow"?: boolean;
        /**
          * Step size on a numeric input
         */
        "step"?: number;
        /**
          * Trim whitespace from the return value
         */
        "trimWhitespace"?: boolean;
        /**
          * Type of the input
         */
        "type"?: string;
        /**
          * Set the validity of the input
         */
        "valid"?: boolean;
        /**
          * Manual validation
         */
        "validate"?: boolean;
        /**
          * Validate the input on blur
         */
        "validateOnBlur"?: boolean;
        /**
          * Custom validation message
         */
        "validation"?: string;
        /**
          * Value of the input
         */
        "value"?: string;
    }
    /**
     * @parent none
     */
    interface CToast {
        /**
          * Messages
         */
        "message"?: CToastMessage;
        /**
          * Emit inner value change to parent
         */
        "onClose"?: (event: CToastCustomEvent<CToastMessage>) => void;
    }
    /**
     * @group Popups
     */
    interface CToasts {
        /**
          * Use absolute positioning
         */
        "absolute"?: boolean;
        /**
          * Horizontal position
         */
        "horizontal"?: 'left' | 'center' | 'right';
        /**
          * Vertical position
         */
        "vertical"?: 'top' | 'bottom';
    }
    /**
     * @group Navigation
     */
    interface CToolbar {
    }
    interface IntrinsicElements {
        "c-accordion": CAccordion;
        "c-accordion-item": CAccordionItem;
        "c-alert": CAlert;
        "c-autocomplete": CAutocomplete;
        "c-badge": CBadge;
        "c-button": CButton;
        "c-card": CCard;
        "c-card-actions": CCardActions;
        "c-card-content": CCardContent;
        "c-card-title": CCardTitle;
        "c-checkbox": CCheckbox;
        "c-csc-logo": CCscLogo;
        "c-data-table": CDataTable;
        "c-dropdown": CDropdown;
        "c-icon": CIcon;
        "c-icon-button": CIconButton;
        "c-input": CInput;
        "c-link": CLink;
        "c-list": CList;
        "c-list-item": CListItem;
        "c-list-item-title": CListItemTitle;
        "c-loader": CLoader;
        "c-login-button": CLoginButton;
        "c-login-buttons": CLoginButtons;
        "c-login-card": CLoginCard;
        "c-login-card-actions": CLoginCardActions;
        "c-login-card-content": CLoginCardContent;
        "c-login-card-title": CLoginCardTitle;
        "c-main": CMain;
        "c-menu": CMenu;
        "c-menu-items": CMenuItems;
        "c-message": CMessage;
        "c-modal": CModal;
        "c-navigation-button": CNavigationButton;
        "c-option": COption;
        "c-option-value": COptionValue;
        "c-otp-input": COtpInput;
        "c-page": CPage;
        "c-pagination": CPagination;
        "c-progress-bar": CProgressBar;
        "c-radio": CRadio;
        "c-radio-group": CRadioGroup;
        "c-ripple": CRipple;
        "c-row": CRow;
        "c-select": CSelect;
        "c-side-navigation": CSideNavigation;
        "c-side-navigation-item": CSideNavigationItem;
        "c-side-navigation-title": CSideNavigationTitle;
        "c-slider": CSlider;
        "c-spacer": CSpacer;
        "c-spinner": CSpinner;
        "c-status": CStatus;
        "c-step": CStep;
        "c-steps": CSteps;
        "c-sub-navigation-item": CSubNavigationItem;
        "c-swiper": CSwiper;
        "c-swiper-tab": CSwiperTab;
        "c-switch": CSwitch;
        "c-tab": CTab;
        "c-tab-buttons": CTabButtons;
        "c-tab-item": CTabItem;
        "c-tab-items": CTabItems;
        "c-table": CTable;
        "c-tabs": CTabs;
        "c-tag": CTag;
        "c-tags": CTags;
        "c-text-field": CTextField;
        "c-toast": CToast;
        "c-toasts": CToasts;
        "c-toolbar": CToolbar;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            /**
             * @group Content Selectors
             */
            "c-accordion": LocalJSX.CAccordion & JSXBase.HTMLAttributes<HTMLCAccordionElement>;
            /**
             * @parent c-accordion
             */
            "c-accordion-item": LocalJSX.CAccordionItem & JSXBase.HTMLAttributes<HTMLCAccordionItemElement>;
            /**
             * @group Indicators
             */
            "c-alert": LocalJSX.CAlert & JSXBase.HTMLAttributes<HTMLCAlertElement>;
            /**
             * @group Form
             */
            "c-autocomplete": LocalJSX.CAutocomplete & JSXBase.HTMLAttributes<HTMLCAutocompleteElement>;
            /**
             * @parent none
             */
            "c-badge": LocalJSX.CBadge & JSXBase.HTMLAttributes<HTMLCBadgeElement>;
            /**
             * @group Buttons
             */
            "c-button": LocalJSX.CButton & JSXBase.HTMLAttributes<HTMLCButtonElement>;
            /**
             * @group Cards
             */
            "c-card": LocalJSX.CCard & JSXBase.HTMLAttributes<HTMLCCardElement>;
            /**
             * @parent c-card
             */
            "c-card-actions": LocalJSX.CCardActions & JSXBase.HTMLAttributes<HTMLCCardActionsElement>;
            /**
             * @parent c-card
             */
            "c-card-content": LocalJSX.CCardContent & JSXBase.HTMLAttributes<HTMLCCardContentElement>;
            /**
             * @parent c-card
             */
            "c-card-title": LocalJSX.CCardTitle & JSXBase.HTMLAttributes<HTMLCCardTitleElement>;
            /**
             * @group Form
             */
            "c-checkbox": LocalJSX.CCheckbox & JSXBase.HTMLAttributes<HTMLCCheckboxElement>;
            /**
             * @parent c-toolbar
             */
            "c-csc-logo": LocalJSX.CCscLogo & JSXBase.HTMLAttributes<HTMLCCscLogoElement>;
            /**
             * @group Tables
             */
            "c-data-table": LocalJSX.CDataTable & JSXBase.HTMLAttributes<HTMLCDataTableElement>;
            "c-dropdown": LocalJSX.CDropdown & JSXBase.HTMLAttributes<HTMLCDropdownElement>;
            /**
             * @group Other
             */
            "c-icon": LocalJSX.CIcon & JSXBase.HTMLAttributes<HTMLCIconElement>;
            /**
             * @group Buttons
             */
            "c-icon-button": LocalJSX.CIconButton & JSXBase.HTMLAttributes<HTMLCIconButtonElement>;
            /**
             * @parent None
             */
            "c-input": LocalJSX.CInput & JSXBase.HTMLAttributes<HTMLCInputElement>;
            /**
             * Basic hyperlink component
             * @group Buttons
             */
            "c-link": LocalJSX.CLink & JSXBase.HTMLAttributes<HTMLCLinkElement>;
            /**
             * @group Other
             */
            "c-list": LocalJSX.CList & JSXBase.HTMLAttributes<HTMLCListElement>;
            "c-list-item": LocalJSX.CListItem & JSXBase.HTMLAttributes<HTMLCListItemElement>;
            "c-list-item-title": LocalJSX.CListItemTitle & JSXBase.HTMLAttributes<HTMLCListItemTitleElement>;
            /**
             * A loader component that fills the nearest containing element that has css-property position set to 'relative'
             * @group Indicators
             */
            "c-loader": LocalJSX.CLoader & JSXBase.HTMLAttributes<HTMLCLoaderElement>;
            /**
             * @parent c-login-buttons
             */
            "c-login-button": LocalJSX.CLoginButton & JSXBase.HTMLAttributes<HTMLCLoginButtonElement>;
            /**
             * @group buttons
             */
            "c-login-buttons": LocalJSX.CLoginButtons & JSXBase.HTMLAttributes<HTMLCLoginButtonsElement>;
            /**
             * @group Cards
             */
            "c-login-card": LocalJSX.CLoginCard & JSXBase.HTMLAttributes<HTMLCLoginCardElement>;
            /**
             * @parent c-login-card
             */
            "c-login-card-actions": LocalJSX.CLoginCardActions & JSXBase.HTMLAttributes<HTMLCLoginCardActionsElement>;
            /**
             * @parent c-login-card
             */
            "c-login-card-content": LocalJSX.CLoginCardContent & JSXBase.HTMLAttributes<HTMLCLoginCardContentElement>;
            /**
             * @parent c-login-card
             */
            "c-login-card-title": LocalJSX.CLoginCardTitle & JSXBase.HTMLAttributes<HTMLCLoginCardTitleElement>;
            /**
             * Wrapper component for the whole page
             * @group Layout
             */
            "c-main": LocalJSX.CMain & JSXBase.HTMLAttributes<HTMLCMainElement>;
            /**
             * @group Navigation
             */
            "c-menu": LocalJSX.CMenu & JSXBase.HTMLAttributes<HTMLCMenuElement>;
            /**
             * @parent c-menu
             */
            "c-menu-items": LocalJSX.CMenuItems & JSXBase.HTMLAttributes<HTMLCMenuItemsElement>;
            /**
             * @parent None
             */
            "c-message": LocalJSX.CMessage & JSXBase.HTMLAttributes<HTMLCMessageElement>;
            /**
             * @group Popups
             */
            "c-modal": LocalJSX.CModal & JSXBase.HTMLAttributes<HTMLCModalElement>;
            /**
             * @parent c-toolbar
             */
            "c-navigation-button": LocalJSX.CNavigationButton & JSXBase.HTMLAttributes<HTMLCNavigationButtonElement>;
            /**
             * @parent c-select
             */
            "c-option": LocalJSX.COption & JSXBase.HTMLAttributes<HTMLCOptionElement>;
            "c-option-value": LocalJSX.COptionValue & JSXBase.HTMLAttributes<HTMLCOptionValueElement>;
            /**
             * @group Form
             */
            "c-otp-input": LocalJSX.COtpInput & JSXBase.HTMLAttributes<HTMLCOtpInputElement>;
            /**
             * @group Layout
             */
            "c-page": LocalJSX.CPage & JSXBase.HTMLAttributes<HTMLCPageElement>;
            /**
             * @group Navigation
             */
            "c-pagination": LocalJSX.CPagination & JSXBase.HTMLAttributes<HTMLCPaginationElement>;
            /**
             * @group Indicators
             */
            "c-progress-bar": LocalJSX.CProgressBar & JSXBase.HTMLAttributes<HTMLCProgressBarElement>;
            /**
             * @parent c-radio-group
             */
            "c-radio": LocalJSX.CRadio & JSXBase.HTMLAttributes<HTMLCRadioElement>;
            /**
             * @group Form
             */
            "c-radio-group": LocalJSX.CRadioGroup & JSXBase.HTMLAttributes<HTMLCRadioGroupElement>;
            /**
             * @parent None
             */
            "c-ripple": LocalJSX.CRipple & JSXBase.HTMLAttributes<HTMLCRippleElement>;
            /**
             * Generic flex row component
             * @group Layout
             */
            "c-row": LocalJSX.CRow & JSXBase.HTMLAttributes<HTMLCRowElement>;
            /**
             * @group Form
             */
            "c-select": LocalJSX.CSelect & JSXBase.HTMLAttributes<HTMLCSelectElement>;
            /**
             * @group Navigation
             */
            "c-side-navigation": LocalJSX.CSideNavigation & JSXBase.HTMLAttributes<HTMLCSideNavigationElement>;
            /**
             * @parent c-side-navigation
             */
            "c-side-navigation-item": LocalJSX.CSideNavigationItem & JSXBase.HTMLAttributes<HTMLCSideNavigationItemElement>;
            /**
             * @parent c-side-navigation
             */
            "c-side-navigation-title": LocalJSX.CSideNavigationTitle & JSXBase.HTMLAttributes<HTMLCSideNavigationTitleElement>;
            /**
             * @group Form
             */
            "c-slider": LocalJSX.CSlider & JSXBase.HTMLAttributes<HTMLCSliderElement>;
            /**
             * Spacer component for flex containers
             * @group Layout
             */
            "c-spacer": LocalJSX.CSpacer & JSXBase.HTMLAttributes<HTMLCSpacerElement>;
            /**
             * @group indicators
             */
            "c-spinner": LocalJSX.CSpinner & JSXBase.HTMLAttributes<HTMLCSpinnerElement>;
            /**
             * @group Indicators
             */
            "c-status": LocalJSX.CStatus & JSXBase.HTMLAttributes<HTMLCStatusElement>;
            /**
             * @group Indicators
             * @parent c-steps
             */
            "c-step": LocalJSX.CStep & JSXBase.HTMLAttributes<HTMLCStepElement>;
            /**
             * @group Indicators
             */
            "c-steps": LocalJSX.CSteps & JSXBase.HTMLAttributes<HTMLCStepsElement>;
            /**
             * @parent c-side-navigation
             */
            "c-sub-navigation-item": LocalJSX.CSubNavigationItem & JSXBase.HTMLAttributes<HTMLCSubNavigationItemElement>;
            /**
             * @group Content Selectors
             */
            "c-swiper": LocalJSX.CSwiper & JSXBase.HTMLAttributes<HTMLCSwiperElement>;
            /**
             * @parent c-swiper
             */
            "c-swiper-tab": LocalJSX.CSwiperTab & JSXBase.HTMLAttributes<HTMLCSwiperTabElement>;
            /**
             * @group Form
             */
            "c-switch": LocalJSX.CSwitch & JSXBase.HTMLAttributes<HTMLCSwitchElement>;
            /**
             * @group Tabs
             * @parent c-tabs
             */
            "c-tab": LocalJSX.CTab & JSXBase.HTMLAttributes<HTMLCTabElement>;
            /**
             * @group Content Selectors
             */
            "c-tab-buttons": LocalJSX.CTabButtons & JSXBase.HTMLAttributes<HTMLCTabButtonsElement>;
            /**
             * @parent c-tabs
             */
            "c-tab-item": LocalJSX.CTabItem & JSXBase.HTMLAttributes<HTMLCTabItemElement>;
            /**
             * @parent c-tabs
             */
            "c-tab-items": LocalJSX.CTabItems & JSXBase.HTMLAttributes<HTMLCTabItemsElement>;
            /**
             * @group tables
             */
            "c-table": LocalJSX.CTable & JSXBase.HTMLAttributes<HTMLCTableElement>;
            /**
             * @group Content Selectors
             */
            "c-tabs": LocalJSX.CTabs & JSXBase.HTMLAttributes<HTMLCTabsElement>;
            /**
             * @parent c-tags
             */
            "c-tag": LocalJSX.CTag & JSXBase.HTMLAttributes<HTMLCTagElement>;
            /**
             * @group buttons
             */
            "c-tags": LocalJSX.CTags & JSXBase.HTMLAttributes<HTMLCTagsElement>;
            /**
             * @group Form
             */
            "c-text-field": LocalJSX.CTextField & JSXBase.HTMLAttributes<HTMLCTextFieldElement>;
            /**
             * @parent none
             */
            "c-toast": LocalJSX.CToast & JSXBase.HTMLAttributes<HTMLCToastElement>;
            /**
             * @group Popups
             */
            "c-toasts": LocalJSX.CToasts & JSXBase.HTMLAttributes<HTMLCToastsElement>;
            /**
             * @group Navigation
             */
            "c-toolbar": LocalJSX.CToolbar & JSXBase.HTMLAttributes<HTMLCToolbarElement>;
        }
    }
}
